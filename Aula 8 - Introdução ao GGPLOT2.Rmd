---
title: "Aula 8 - Introdu√ß√£o ao GGPLOT2"
subtitle: "Material adaptado do curso '[A ggplot2 Tutorial for Beautiful Plotting in R ](https://www.cedricscherer.com/2019/08/05/a-ggplot2-tutorial-for-beautiful-plotting-in-r/)'"
author: "Claudiano Neto"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Introductory Words

[I don't care, just show me the content!](#toc)


## Table of Content {#toc}

* [Prepara√ß√£o](#prep)
* [O conjunto de dados](#data)
* [O Pacote `{ggplot2}`](#ggplot)
* [Um ggplot padr√£o](#default)
* [Trabalhando com Eixos](#axes)
* [Trabalhando com Titulos](#titles)
* [Trabalhando com Legendas](#legends)
* [Trabalhando com Planos de fundo e linhas de grade](#style)
* [Trabalhando com margens](#margins)
* [Trabalhando com Gr√°ficos de v√°rios pain√©is](#panels)
* [Trabalhando com Cores](#colors)
* [Trabalhando com Temas](#themes)
* [Trabalhando com Linhas](#lines)
* [Trabalhando com Texto](#text)
* [Trabalhando com Coordenadas](#coords)
* [Trabalhando com Tipos de Gr√°ficos](#charts)
* [Trabalhando com Ribbons (AUC, CI, etc.)](#ribbons)
* [Trabalhando com Smoothings](#smooths)
* [Trabalhando com Plots Interativos](#interactive)
* [Observa√ß√µes, dicas e recursos](#tipps)



## Prepara√ß√£o {#prep}

* Voc√™ pode encontrar o script Rmarkdown com o c√≥digo executado nesta postagem do blog [aqui] (https://github.com/Z3tt/Z3tt/blob/master/content/post/2019-08-05_ggplot2-tutorial.Rmd).
* Voc√™ tamb√©m pode baixar o script R contendo apenas o c√≥digo [aqui] (https://cedricscherer.netlify.app/codes/ggplot-tutorial-cedric-raw.R).
* Voc√™ precisa instalar os seguintes pacotes para executar o tutorial completo:
    + `{ggplot2}`, parte da cole√ß√£o de pacotes `{tidyverse}`
    + `{tidyverse}` cole√ß√£o de pacotes, a saber
      - `{dplyr}` para disputa de dados
      - `{tibble}` para quadros de dados modernos
      - `{tidyr}` para limpeza de dados
      - `{forcats}` para lidar com fatores
    + `{colorspace}` para manipula√ß√£o de cores
    + `{corrr}` para calcular matrizes de correla√ß√£o
    + `{cowplot}` para compor ggplots
    + `{ggdark}` para temas e cores invertidas
    + `{ggforce}` para gr√°ficos sina e outras coisas legais
    + `{ggrepel}` para uma boa rotulagem de texto
    + `{ggridges}` para plotagens de cume
    + `{ggsci}` para belas paletas de cores
    + `{ggtext}` para renderiza√ß√£o avan√ßada de texto
    + `{ggthemes}` para temas adicionais
    + `{grid}` para a cria√ß√£o de objetos gr√°ficos
    + `{gridExtra}` para fun√ß√µes adicionais para gr√°ficos de "grade"
    + `{patchwork}` para gr√°ficos de m√∫ltiplos pain√©is
    + `{rcartocolor}` para √≥timas paletas de cores
    + `{scico}` para paletas uniformes de percep√ß√£o
    + `{showtext}` para fontes personalizadas
    + `{brilhante}` para aplicativos interativos
    + uma s√©rie de pacotes para visualiza√ß√µes interativas
      + `{charter}`
      + `{echarts4r}`
      + `{ggiraph}`
      + `{highcharter}`
      + `{plotly}`

```{r install-packages, eval=FALSE}
# instalando do CRAN packages
install.packages(c("tidyverse", "colorspace", "corrr",  "cowplot",
                   "ggdark", "ggforce", "ggrepel", "ggridges", "ggsci",
                   "ggtext", "ggthemes", "grid", "gridExtra", "patchwork",
                   "rcartocolor", "scico", "showtext", "shiny",
                   "plotly", "highcharter", "echarts4r"))
# instalando do GitHub (aqueles fora do CRAN)
install.packages(devtools)
devtools::install_github("JohnCoene/charter")
```

(For teaching reasons and if people jump to any plot, I load the package needed beside `{ggplot2}` in the respective section.)



## O conjunto de Dados {#data}

We are using data from the *National Morbidity and Mortality Air Pollution Study* (NMMAPS). To make the plots manageable we are limiting the data to Chicago and 1997‚Äì2000. For more detail on this data set, consult Roger Peng's book [Statistical Methods in Environmental Epidemiology with R](http://www.springer.com/de/book/9780387781662).
You can download the data we are using during this tutorial [here](https://github.com/Z3tt/R-Tutorials/blob/master/ggplot2/chicago-nmmaps.csv) (but you don't have to).

We can import the data into our R session for example with `read_csv()` from the `{readr}` package. To access the data later, we are storing it in a variable called `chic` by using the *assignment arrow* `<-`.

Estamos usando dados do *National Morbidity and Mortality Air Pollution Study* (NMMAPS). Para tornar os gr√°ficos gerenci√°veis, estamos limitando os dados a Chicago e entre 1997‚Äì2000. Para obter mais detalhes sobre este conjunto de dados, consulte o livro de Roger Peng [M√©todos Estat√≠sticos em Epidemiologia Ambiental com R] (http://www.springer.com/de/book/9780387781662).
Voc√™ pode baixar os dados que estamos usando durante este tutorial [aqui](https://github.com/Z3tt/R-Tutorials/blob/master/ggplot2/chicago-nmmaps.csv), *mas voc√™ n√£o precisa*.

Podemos importar os dados para nossa sess√£o R, por exemplo, com `read_csv()` do pacote `{readr}`. Para acessar os dados posteriormente, estamos armazenando-os em uma vari√°vel chamada `chic` usando a *seta de atribui√ß√£o* `<-`.


```{r data-import, warning=FALSE, message=F}
chic <- readr::read_csv("https://raw.githubusercontent.com/Z3tt/R-Tutorials/master/ggplot2/chicago-nmmaps.csv")
```

üí° **O `::` √© chamado de *namespace* e pode ser usado para acessar uma fun√ß√£o sem carregar o pacote. Aqui, voc√™ tamb√©m pode executar primeiro a fun√ß√£o `library(readr)` e, depois, o comando `chic <- read_csv (...)`**

```{r data-inspection}
tibble::glimpse(chic)
head(chic, 10)
```


## O Pacote `{ggplot2}`{#ggplot}

> `ggplot2` √© um sistema para criar gr√°ficos declarativamente, baseado em [The Grammar of Graphics](https://link.springer.com/chapter/10.1007/978-3-642-21551-3_13). Voc√™ fornece os dados, diz ao `ggplot2` como mapear as vari√°veis para a est√©tica, quais os elementos gr√°ficos b√°sicos usar o `ggplot2` cuida dos detalhes.
Um ggplot √© constru√≠do a partir de alguns elementos b√°sicos:

1.	**Data**:
Os dados brutos que voc√™ deseja plotar.
2.	**Geometries** `geom_`:
Os dados brutos que voc√™ deseja plotar.
3.	**Aesthetics** `aes()`:
Est√©tica dos objetos geom√©tricos e estat√≠sticos, como posi√ß√£o, cor, tamanho, forma e transpar√™ncia
4.	**Scales** `scale_`:
Mapas entre os dados e as dimens√µes est√©ticas, como intervalo de dados para plotar valores de largura ou fator para cores.
5.	**Statistical transformations** `stat_`:
Resumos estat√≠sticos dos dados, como quantis, curvas ajustadas e somas.
6.	**Coordinate system** `coord_`:
A transforma√ß√£o usada para mapear coordenadas de dados no plano do ret√¢ngulo de dados.
7.	**Facets** `facet_`:
A organiza√ß√£o dos dados em uma grade de gr√°ficos.
8.	**Visual themes** `theme()`:
Os padr√µes visuais gerais de um gr√°fico, como plano de fundo, grades, eixos, tipo de letra padr√£o, tamanhos e cores.

üí° **O n√∫mero de elementos pode variar dependendo de como voc√™ os agrupa e a quem voc√™ pergunta.**

## Um ggplot padr√£o {#default}

Primeiro, para poder usar a funcionalidade de `{ggplot2}`, temos que carregar o pacote (que tamb√©m podemos carregar por meio da [cole√ß√£o de pacotes tidyverse](https://www.tidyverse.org/)):

```{r library}
#library(ggplot2)
library(tidyverse)
```

A sintaxe de `{ggplot2}` √© diferente do R base. De acordo com os elementos b√°sicos, um ggplot padr√£o precisa de tr√™s coisas que voc√™ deve especificar: os *dados*, *est√©tica* e uma *geometria*. Sempre come√ßamos a definir um objeto de plotagem chamando `ggplot(data = df)` que apenas informa ao `{ggplot2}` que vamos trabalhar com esses dados. Na maioria dos casos, voc√™ pode querer representar graficamente duas vari√°veis - uma no eixo x e outra no eixo y. Essas s√£o *est√©ticas posicionais* e, portanto, adicionamos `aes(x = var1, y = var2)` √† chamada `ggplot()` (sim, `aes()` significa est√©tica). No entanto, tamb√©m existem casos em que √© necess√°rio especificar uma ou at√© tr√™s ou mais vari√°veis.

üí° **Especificamos os dados *fora* de `aes ()` e adicionamos as vari√°veis para as quais o ggplot mapeia a est√©tica *dentro* de `aes ()`.**

Here, we map the variable `date` to the x position and the variable `temp` to the y position. Later, we will also map variables to all kind of other aesthetics such as color, size, and shape.

```{r ggplot}
(g <- ggplot(chic, aes(x = date, y = temp)))
```

Olha s√≥, apenas um painel √© criado ao executar isso. Por que? Isso ocorre porque `{ggplot2}` n√£o sabe *como* queremos plotar esses dados ‚Äî ainda precisamos fornecer uma geometria!

`ggplot2` permite que voc√™ armazene o `ggobject` atual em uma vari√°vel de sua escolha, atribuindo-o a uma vari√°vel, em nosso caso chamada `g`. Voc√™ pode estender este `ggobject` posteriormente adicionando outras camadas, todas de uma vez ou atribuindo-o √† mesma ou a outra vari√°vel.

üí° **Usando par√™nteses ao atribuir um objeto, o objeto ser√° impresso imediatamente (ao inv√©s de escrever `g <- ggplot (...)` e ent√£o `g` n√≥s simplesmente escrevemos` (g <- ggplot (...) ) `).**

Existem muitas, muitas geometrias diferentes (chamadas *geoms* porque cada fun√ß√£o geralmente come√ßa com `geom_`) que podem ser adicionadas a um ggplot por padr√£o (veja [aqui](https://ggplot2.tidyverse.org/reference/) para uma lista completa) e ainda mais fornecidos por pacotes de extens√£o (veja [aqui](https://exts.ggplot2.tidyverse.org/) para uma cole√ß√£o de pacotes de extens√£o). Vamos dizer ao `{ggplot2}` qual estilo queremos usar, por exemplo, adicionando `geom_point()` para criar um gr√°fico de dispers√£o:

```{r ggplot-default}
g + geom_point()
```

Massa! Mas esses dados tamb√©m podem ser visualizados como um gr√°fico linear (n√£o √© o ideal, mas as pessoas fazem coisas assim o tempo todo). Ent√£o, simplesmente adicionamos `geom_line()` e voil√°:

```{r ggplot-default-line}
g + geom_line()
```

N√≥s tamb√©m podemos combinar v√°rias outras camadas geom√©tricas - e √© aqui que a magia e a divers√£o come√ßam!

```{r ggplot-default-line-point}
g + geom_line() + geom_point()
```

Por enquanto, √© isso sobre geometrias. N√£o se preocupe, vamos aprender v√°rios tipos de plots em [um ponto posterior](#charts).


##### Alterar as propriedades das geometrias

Dentro do comando `geom_ *`, voc√™ j√° pode manipular a est√©tica visual, como a cor, forma e tamanho de seus pontos. Vamos transformar todos os pontos em grandes diamantes vermelho-fogo!

```{r ggplot-default-col-size-shape}
g + geom_point(color = "firebrick", shape = "diamond", size = 2)
```

üí°**`{ggplot2}` compreende `color` e` colour`, bem como a vers√£o curta `col`. **

<details>
  <summary>&#128129; <i>You can use preset colors (here is a [full list](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)) or [hex color codes](https://www.techopedia.com/definition/29788/color-hex-code), both in quotes, and even RGB/RGBA colors by using the `rgb()` function. Expand to see example.</i></summary>
  
  <details>
   <summary>&#128129; <i>Voc√™ pode usar cores predefinidas (aqui est√° uma [lista completa] (http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)) ou [c√≥digos de cores hexadecimais] (https://www.techopedia.com/definition/29788/color-hex-code), ambos entre aspas e at√© mesmo cores RGB / RGBA usando a fun√ß√£o `rgb ()`. Expanda para ver o exemplo.</i></summary>

```{r ggplot-default-col-size-hex-rgb, eval=FALSE}
g + geom_point(color = "#b22222", shape = "diamond", size = 2)
g + geom_point(color = rgb(178, 34, 34, maxColorValue = 255), shape = "diamond", size = 2)
```

```{r ggplot-default-col-size-hex-rgb-plot, echo=FALSE, purl=FALSE}
library(patchwork)
a <- g + geom_point(color = "#b22222", shape = "diamond", size = 2)
b <- g + geom_point(color = rgb(178, 34, 34, maxColorValue = 255), shape = "diamond", size = 2)
a + b
```

</details>

Cada geom vem com suas pr√≥prias propriedades (chamadas *argumentos*) e o mesmo argumento pode resultar em uma mudan√ßa diferente dependendo do geom que voc√™ est√° usando.

```{r ggplot-default-line_col-size-shape}
g + geom_point(color = "firebrick", shape = "diamond", size = 2) +
    geom_line(color = "firebrick", linetype = "dotted", size = .3)
```


##### Substitua o tema padr√£o `ggplot2`

E para ilustrar um pouco mais a versatilidade do ggplot, vamos nos livrar da apar√™ncia cinza padr√£o `{ggplot2}` definindo um tema integrado diferente, por exemplo, `theme_bw()` ‚Äî chamando `theme_set()` todos os gr√°ficos seguintes ter√£o o mesmo tema preto e branco. Os pontos vermelhos parecem muito melhores agora!

```{r remove-gray-background}
theme_set(theme_bw())
g + geom_point(color = "firebrick")
```

Voc√™ pode saber mais sobre como usar temas embutidos e como personalizar temas na se√ß√£o ["Trabalhando com Temas"](# temas). A partir do pr√≥ximo cap√≠tulo, tamb√©m usaremos a fun√ß√£o `theme()` para personalizar elementos particulares do tema.

üí° **`theme()` √© um comando essencial para modificar manualmente todos os tipos de elementos do tema (textos, ret√¢ngulos e linhas).**

Para ver quais detalhes de um tema ggplot podem ser modificados, d√™ uma olhada [aqui] (https://ggplot2.tidyverse.org/reference/theme.html) ‚Äî e demore algum tempo, esta √© uma lista looonga.

[‚Üë Volte para o √çndice.](#toc)<br><br>



## Trabalhando com Eixos {#axes}

##### Alterar os t√≠tulos dos eixos

Vamos adicionar alguns r√≥tulos bem escritos aos eixos. Para isso, adicionamos `labs()` fornecendo uma string de caracteres para cada r√≥tulo que queremos alterar (aqui, `x` e` y`):

```{r axis-labs}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)")
```

<details>
  <summary>&#128129; <i>Voc√™ tamb√©m pode adicionar cada t√≠tulo de eixo via `xlab()` e `ylab()`. Expanda para ver um exemplo.</i></summary>
```{r axis-labs-2}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  xlab("Ano") +
  ylab("Temperatura (¬∞F)")
```
</details>

Usually you can also specify symbols by simply adding the symbol itself (here "¬∞") but the code below also allows to add not only symbols but e.g. superscripts:

```{r axis-labs-expression}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = expression(paste("Temperatura (", degree ~ F, ")"^"(Ei, por que devemos usar unidades m√©tricas?!)")))
```


##### Aumente o espa√ßo entre o eixo e os t√≠tulos do eixo

`theme()` √© um comando essencial para modificar elementos espec√≠ficos do tema (textos e t√≠tulos, caixas, s√≠mbolos, planos de fundo, ...). Vamos us√°-los muito! Por enquanto, vamos modificar elementos de texto. Podemos alterar as propriedades de todos ou de elementos de texto espec√≠ficos (aqui t√≠tulos de eixo) sobrescrevendo o `element_text()` padr√£o na chamada `theme()`:

```{r labs-move-away-vjust}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.title.x = element_text(vjust = 0, size = 15),
        axis.title.y = element_text(vjust = 2, size = 15))
```

`vjust` refere-se ao alinhamento vertical, que geralmente varia entre 0 e 1, mas voc√™ tamb√©m pode especificar valores fora desse intervalo. Observe que, embora movamos o t√≠tulo do eixo no eixo y horizontalmente, precisamos especificar `vjust` (que est√° correto da perspectiva do r√≥tulo). Voc√™ tamb√©m pode alterar a dist√¢ncia especificando a margem de ambos os elementos de texto:

```{r labs-move-away-margin}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.title.x = element_text(margin = margin(t = 10), size = 15),
        axis.title.y = element_text(margin = margin(r = 10), size = 15))
```

Os r√≥tulos `t` e` r` dentro do objeto `margin ()` referem-se a *topo* e *direita*, respectivamente. Voc√™ tamb√©m pode especificar as quatro margens como `margem (t, r, b, l)`. Observe que agora temos que alterar a margem direita para modificar o espa√ßo no eixo y, n√£o a margem inferior.

üí° **Uma boa maneira de lembrar a ordem dos lados da margem √© "*t*-*r*-oub-*l*-*e*".**


##### Alterar a est√©tica dos t√≠tulos dos eixos

Novamente, usamos a fun√ß√£o `theme()` e modificamos o elemento `axis.title` e / ou os elementos subordinados` axis.title.x` e `axis.title.y`. Dentro de `element_text()` podemos, por exemplo, sobrescrever os padr√µes para `size`,` color` e `face`:

```{r labs-color-axes-1}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.title = element_text(size = 15, color = "firebrick",
                                  face = "italic"))
```

O argumento `face` pode ser usado para tornar a fonte negritada - `bold`, ou it√°lico - `italic`, ou at√© mesmo negrito-it√°lico -  `bold.italic`.

```{r labs-color-axes-2}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.title.x = element_text(color = "sienna", size = 15),
        axis.title.y = element_text(color = "orangered", size = 15))
```

<details>
  <summary>&#128129; <i> You could also use a combination of `axis.title` and `axis.title.y`, since `axis.title.x` inherits the values from `axis.title`. Expand to see example.</i></summary>
```{r labs-color-axes-3}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.title = element_text(color = "sienna", size = 15),
        axis.title.y = element_text(color = "orangered", size = 15))
```
</details>

√â poss√≠vel modificar algumas propriedades para ambos os t√≠tulos dos eixos e outras apenas para um ou propriedades para cada um por si:

```{r labs-color-axes-4}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.title = element_text(color = "sienna", size = 15, face = "bold"),
        axis.title.y = element_text(face = "bold.italic"))
```


##### Alterar a est√©tica do texto do eixo

Da mesma forma, voc√™ tamb√©m pode alterar a apar√™ncia do texto do eixo (aqui *os n√∫meros*) usando `axis.text` e / ou os elementos subordinados `axis.text.x` e `axis.text.y`:

```{r labs-color-axes-text}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.text = element_text(color = "dodgerblue", size = 12),
        axis.text.x = element_text(face = "italic"))
```


##### Girar Texto do Eixo

Especificar um `√¢ngulo` permite girar qualquer elemento de texto. Com `hjust` e` vjust` voc√™ pode ajustar a posi√ß√£o do texto depois horizontalmente (0 = esquerda, 1 = direita) e verticalmente (0 = superior, 1 = inferior):

```{r axis-text}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.text.x = element_text(angle = 50, vjust = 1, hjust = 1, size = 12))
```


##### Remover Texto do Eixo e Tiquetaques

Pode haver raramente um motivo para fazer isso, mas √© assim que funciona:

```{r axis-no-labs}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank())
```

Eu introduzi tr√™s elementos de tema - texto, linhas e ret√¢ngulos - mas na verdade h√° mais um: `element_blank()` que remove o elemento (e, portanto, n√£o √© considerado um elemento oficial).

üí° **Se voc√™ quiser se livrar de um elemento de tema, o elemento √© sempre `element_blank()`.**


##### Remover t√≠tulos de eixo

Poder√≠amos usar novamente `theme_blank()` mas √© muito mais simples remover o r√≥tulo na chamada `labs()` (ou `xlab()`):

```{r axis-no-title}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = NULL, y = "")
```

üí° **Observe que `NULL` remove o elemento (semelhante a `element_blank()`), enquanto as aspas vazias `""` manter√£o o espa√ßamento para o t√≠tulo do eixo e simplesmente n√£o imprimir√£o nada.**

##### Limite do intervalo do eixo

√Äs vezes, voc√™ deseja <s>ampliar</s> para dar uma olhada mais de perto em alguns intervalos de seus dados. Voc√™ pode fazer isso sem subdividir seus dados:

```{r axis-limit}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  ylim(c(0, 50)) # limitando de 0 a 50
```

Alternativamente, voc√™ pode usar `scale_y_continuous(limits = c(0, 50))` ou `coord_cartesian(ylim = c(0, 50))`. O primeiro remove todos os pontos de dados fora do intervalo, enquanto o segundo ajusta a √°rea vis√≠vel e √© semelhante a `ylim(c(0, 50))`. Voc√™ pode se perguntar: *Ent√£o, no final, ambos resultam no mesmo.* Mas n√£o realmente, h√° uma diferen√ßa importante - compare os dois gr√°ficos a seguir:

```{r axis-limit-comp, echo=FALSE, purl=FALSE}
p1 <- ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  scale_y_continuous(limits = c(0, 50)) +
  ggtitle("scale_y_continuous(limits) or ylim()")
p2 <- ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  coord_cartesian(ylim = c(0, 50)) +
  ggtitle("coord_cartesian(ylim)")
library(patchwork)
p1 + p2
```

Voc√™ deve ter notado que √† esquerda h√° algum buffer vazio em torno de seus limites y, enquanto √† direita os pontos s√£o plotados at√© a borda e at√© al√©m. Isso ilustra perfeitamente o subconjunto (√† esquerda) versus o zoom (√† direita). Para mostrar por que isso √© importante, vamos dar uma olhada em um tipo de gr√°fico diferente, um gr√°fico de caixa:

```{r axis-limit-comp-box, echo=FALSE, purl=FALSE}
p1 <- ggplot(chic, aes(x = factor(year), y = temp)) +
  geom_boxplot() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  scale_y_continuous(limits = c(0, 50)) +
  ggtitle("scale_y_continuous(limits) or ylim()")
p2 <- ggplot(chic, aes(x = factor(year), y = temp)) +
  geom_boxplot() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  coord_cartesian(ylim = c(0, 50)) +
  ggtitle("coord_cartesian(ylim)")
p1 + p2
```

Hum. Porque `scale_x|y_continuous()` subconjuntos de dados primeiro, obtemos estimativas completamente diferentes (e erradas, pelo menos se no caso este n√£o era seu objetivo) para os gr√°ficos de caixa! Espero que voc√™ n√£o precise voltar aos seus scripts antigos agora e verificar se *talvez* tenha manipulado seus dados enquanto tra√ßava e relatou estat√≠sticas de resumo incorretas em seu relat√≥rio, artigo ou tese ...

##### For√ßar o gr√°fico para come√ßar na origem

Relacionado a isso, voc√™ pode for√ßar R a plotar o gr√°fico come√ßando na origem:

```{r origin}
library(tidyverse)
chic_high <- dplyr::filter(chic, temp > 25, o3 > 20)
ggplot(chic_high, aes(x = temp, y = o3)) +
  geom_point(color = "darkcyan") +
  labs(x = "Temperatura maior do que 25¬∞F",
       y = "Oz√¥nio superior a 20 ppb") +
  expand_limits(x = 0, y = 0)
```

<details>
  <summary>&#128129; <i>Usando `coord_cartesian(xlim = c(0, NA), ylim = c(0, NA))` levar√° ao mesmo resultado. Expanda para ver um exemplo.</i></summary>
  
```{r origin-coord}
library(tidyverse)
chic_high <- dplyr::filter(chic, temp > 25, o3 > 20)
ggplot(chic_high, aes(x = temp, y = o3)) +
  geom_point(color = "darkcyan") +
  labs(x = "Temperatura maior do que 25¬∞F",
       y = "Oz√¥nio superior a 20 ppb") +
  coord_cartesian(xlim = c(0, NA), ylim = c(0, NA))
```
</details>

Mas tamb√©m podemos for√ß√°-lo a come√ßar *literalmente* na origem!

```{r origin-force}
ggplot(chic_high, aes(x = temp, y = o3)) +
  geom_point(color = "darkcyan") +
labs(x = "Temperatura maior do que 25¬∞F",
       y = "Oz√¥nio superior a 20 ppb") +
  expand_limits(x = 0, y = 0) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  coord_cartesian(clip = "off")
```

üí° **O argumento `clip = "off"` em qualquer sistema de coordenadas, sempre come√ßando com `coord_*`, permite desenhar fora da √°rea do painel.**

Aqui, eu o chamo para ter certeza de que as marcas em `c(0, 0)` n√£o s√£o cortadas. Veja o [t√≥pico no Twitter de Claus Wilke](https://twitter.com/clauswilke/status/991542952802619392?lang=en) para mais detalhes.


##### Eixos com a mesma escala

Para fins de demonstra√ß√£o, vamos representar graficamente a temperatura em rela√ß√£o √† temperatura com algum ru√≠do aleat√≥rio. O `coord_equal()` √© um sistema de coordenadas com uma raz√£o especificada que representa o n√∫mero de unidades no eixo y equivalente a uma unidade no eixo x. O padr√£o, `propor√ß√£o = 1`, garante que uma unidade no eixo x tenha o mesmo comprimento que uma unidade no eixo y:

```{r axes-equal}
ggplot(chic, aes(x = temp, y = temp + rnorm(nrow(chic), sd = 20))) +
  geom_point(color = "sienna") +
  labs(x = "Temperatura (¬∞F)", y = "Temperatura (¬∞F) + random noise") +
  xlim(c(0, 100)) + ylim(c(0, 150)) +
  coord_fixed()
```

Raz√µes superiores a um tornam as unidades no eixo y mais longas do que as unidades no eixo x e vice-versa:

```{r axes-fixed-2, fig.height=3}
ggplot(chic, aes(x = temp, y = temp + rnorm(nrow(chic), sd = 20))) +
  geom_point(color = "sienna") +
  labs(x = "Temperatura (¬∞F)", y = "Temperatura (¬∞F) + random noise") +
  xlim(c(0, 100)) + ylim(c(0, 150)) +
  coord_fixed(ratio = 1/5)
```


##### Use uma fun√ß√£o para alterar r√≥tulos

√Äs vezes √© √∫til alterar um pouco seus r√≥tulos, talvez adicionando unidades ou sinais de porcentagem sem adicion√°-los aos dados. Voc√™ pode usar uma fun√ß√£o neste caso:

```{r labs-alt}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = NULL) +
  scale_y_continuous(label = function(x) {return(paste(x, "Graus Fahrenheit"))})
```

[‚Üë Volte para o √çndice.](#toc)<br><br>



## Trabalhando com Titulos {#titles}

##### Adicionar um T√≠tulo

N√≥s podemos adicionar um t√≠tulo via `ggtitle()` function:

```{r title}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  ggtitle("Temperaturas em Chicago")
```

Alternativamente, voc√™ pode usar `labs()`. Aqui voc√™ pode adicionar v√°rios argumentos, por exemplo al√©m disso, uma legenda, uma legenda e uma tag (bem como t√≠tulos de eixo, conforme mostrado antes):

```{r title-labs}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)",
       title = "Temperaturas em Chicago",
       subtitle = "Padr√£o sazonal de temperaturas di√°rias de 1997 a 2001",
       caption = "Dados: NMMAPS",
       tag = "Fig. 1")
```


##### Torne o t√≠tulo em negrito e adicione um espa√ßo na linha de base

Novamente, uma vez que queremos modificar as propriedades de um elemento de tema, usamos a fun√ß√£o `theme()` e como para os elementos de texto `axis.title` e` axis.text` modificamos a face da fonte e a margem. Todas as seguintes modifica√ß√µes de elementos do tema funcionam n√£o apenas para o t√≠tulo, mas para todos os outros r√≥tulos, como `plot.subtitle`,` plot.caption`, `plot.caption`,` legend.title`, `legend.text`, e `axis.title` e` axis.text`.

```{r title-bold}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)",
       title = "Temperaturas em Chicago") +
  theme(plot.title = element_text(face = "bold",
                                  margin = margin(10, 0, 10, 0),
                                  size = 14))
```

üí° **Uma boa maneira de lembrar a ordem dos argumentos de margem √© " *t*-*r*-oub-*l*-*e*" que se assemelha √† primeira letra dos quatro lados.**


##### Ajuste de Posi√ß√£o dos T√≠tulos

O alinhamento geral (left, center, right) √© controlado por `hjust` (que significa ajuste horizontal):

```{r title-adjust}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = NULL,
       title = "Temperaturas em Chicago",
       caption = "Dados: NMMAPS") +
  theme(plot.title = element_text(hjust = 1, size = 16, face = "bold.italic"))
```

Claro, l√° tamb√©m √© poss√≠vel ajustar o alinhamento vertical, controlado por `vjust`.

Desde 2019, o usu√°rio pode especificar o alinhamento do t√≠tulo, subt√≠tulo e legenda com base na √°rea do painel (o padr√£o) ou na margem do gr√°fico por meio de `plot.title.position` e` plot.caption.position`. O √∫ltimo √© na verdade a melhor escolha em termos de design na maioria dos casos e muitas pessoas ficaram muito felizes com esse novo recurso, pois especialmente com r√≥tulos de eixo y muito longos, o alinhamento parece horr√≠vel:

```{r title-position-default}
(g <- ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  scale_y_continuous(label = function(x) {return(paste(x, "Graus Fahrenheit"))}) +
  labs(x = "Ano", y = NULL,
       title = "Temperaturas em Chicago entre 1997 e 2001 em graus Fahrenheit",
       caption = "Dados: NMMAPS") +
  theme(plot.title = element_text(size = 14, face = "bold.italic"),
        plot.caption = element_text(hjust = 0)))
```

```{r title-position-plot}
g + theme(plot.title.position = "plot",
          plot.caption.position = "plot")
```


##### Use uma fonte n√£o tradicional em seu t√≠tulo

Voc√™ tamb√©m pode usar fontes diferentes, n√£o apenas a padr√£o fornecida pelo ggplot (e que difere entre os sistemas operacionais). Existem v√°rios pacotes que o ajudam a usar fontes que est√£o instaladas em sua m√°quina (e voc√™ pode estar usando em seu programa de escrit√≥rio). Aqui, eu uso o [pacote `showtext`](https://github.com/yixuan/showtext) que facilita o uso de v√°rios tipos de fontes (TrueType, OpenType, Type 1, fontes da web, etc.) em R parcelas. Depois de carregar o pacote, voc√™ tamb√©m precisa importar a fonte que deve ser instalada em seu dispositivo. Eu uso regularmente [fontes do Google](https://fonts.google.com/) que podem ser importadas com a fun√ß√£o `font_add_google()`, mas voc√™ tamb√©m pode adicionar outras fontes com `font_add()`. (Observe que mesmo no caso de usar fontes do Google, voc√™ deve instalar a fonte - e reiniciar o Rstudio - para usar a fonte.)

```{r showtext, message = FALSE}
library(showtext)
font_add_google("Playfair Display", ## name of Google font
                "Playfair")  ## name that will be used in R
font_add_google("Bangers", "Bangers")
```

Agora, podemos usar essas fam√≠lias de fontes usando - sim, voc√™ adivinhou certo - `theme()`:

```{r title-style}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)",
       title = "Temperaturas em Chicago",
       subtitle = "Temperaturas Diarias em Chicago entre 1997 e 2001 em graus Fahrenheit") +
  theme(plot.title = element_text(family = "Bangers", hjust = .5, size = 25),
        plot.subtitle = element_text(family = "Playfair", hjust = .5, size = 15))
```

Voc√™ tamb√©m pode definir uma fonte n√£o padr√£o para todos os elementos de texto de seus gr√°ficos, para mais detalhes consulte a se√ß√£o ["Trabalhando com Temas"](#themes). Vou usar *Roboto Condensed* como a nova fonte para todos os gr√°ficos seguintes.

```{r default-font}
font_add_google("Roboto Condensed", "Roboto Condensed")
theme_set(theme_bw(base_size = 12, base_family = "Roboto Condensed"))
```

<p style='color:gray;'>(Previously, this tutorial used the [{extrafont} package](https://cran.r-project.org/web/packages/extrafont/README.html), which did a great job until last year. All of the sudden I couldn't add any new fonts anymore and after getting a new laptop, the package did not find any fonts at all... I usually suggest the [{ragg} package](https://ragg.r-lib.org/) now. However, I did not succeed to make it work for my homepage so I use the `{showtext}` package which is great as well with the only main difference that you need to import the font you want to use explicitly with `{showtext}`. However, it seems [there are some technical details that are not solved optimally by `{showtext}`](https://twitter.com/thomasp85/status/1355083725156077571) so you may want to use the package as a very last resort.)</p>

<p style='color:gray;'>(O pacote`{showtext}` √© √≥timo, mas com ele voc√™ precisa importar a fonte que deseja usar explicitamente com `{showtext}`. No entanto, parece [existem alguns detalhes t√©cnicos que n√£o s√£o resolvidos de forma otimizada por `{showtext}`] (https://twitter.com/thomasp85/status/1355083725156077571) ent√£o voc√™ pode querer usar o pacote como √∫ltimo recurso.)</p>


##### Alterar espa√ßamento em texto multilinha

Voc√™ pode usar o argumento `lineheight` para alterar o espa√ßamento entre as linhas. Neste exemplo, as linhas foram espremidas juntas (altura da linha < 1).
```{r multiline-title}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  ggtitle("Temperaturas em Chicago\nde 1997 a 2001") +
  theme(plot.title = element_text(lineheight = .8, size = 16))
```

[‚Üë Voltar para o √çndice.](#toc)<br><br>



## Trabalhando com Legendas {#legends}

Iremos codificar o enredo por cores com base na esta√ß√£o. Ou para express√°-lo de uma forma mais ggplot'ish: mapeamos a vari√°vel `season` para a `aes`thetic `color`. Uma coisa boa sobre `{ggplot2}` √© que ele adiciona uma legenda por padr√£o ao mapear uma vari√°vel para uma est√©tica. Voc√™ pode ver que, por padr√£o, o t√≠tulo da legenda √© o que especificamos no argumento de cor:

```{r legend-default}
ggplot(chic,
       aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)")
```


##### Desligar a legenda

Sempre uma das primeiras perguntas √©: "Como posso me livrar da legenda?".

√â muito f√°cil e sempre funciona com `theme (legend.position = "none")`:

```{r legend-none}
ggplot(chic,
       aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(legend.position = "none")
```

Voc√™ tamb√©m pode usar `guias (color = "none")` ou `scale_color_discrete (guide = "none")` dependendo do caso espec√≠fico. Embora a altera√ß√£o do elemento do tema remova todas as legendas de uma vez, voc√™ pode remover legendas espec√≠ficas com as √∫ltimas op√ß√µes, mantendo algumas outras:

```{r legend-none-guides}
ggplot(chic,
       aes(x = date, y = temp,
           color = season, shape = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  guides(color = "none")
```

Aqui por exemplo, mantivemos a legenda para as formas - `shape`, enquanto descarta a das cores - `color`.


##### Remover t√≠tulos de legenda

Como j√° aprendemos, use `element_blank()` para n√£o desenhar *nada* no t√≠tulo:

```{r legend-title-off}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(legend.title = element_blank())
```

<details>
  <summary>&#128129; <i>Voc√™ pode conseguir o mesmo definindo o nome da legenda para `NULL`, tanto via `scale_color_discrete (name = NULL)` ou `labs (color = NULL)`. Expanda para ver exemplos.</i></summary>
```{r legend-title-null}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  scale_color_discrete(name = NULL)
```

```{r legend-title-labs-null}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  labs(color = NULL)
```
</details>

##### Mudar posi√ß√£o da legenda

Se voc√™ quiser colocar a legenda n√£o √† direita, pode-se usar `legend.position` como argumento em `theme`. As posi√ß√µes poss√≠veis s√£o "top", "right" (que √© o padr√£o), "bottom" e "left".

```{r legend-top}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(legend.position = "top")
```

Voc√™ tamb√©m pode colocar a legenda dentro do painel especificando um vetor com as coordenadas `x` e` y` relativas variando de 0 (esquerda ou inferior) a 1 (direita ou superior):

```{r legend-inside}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)",
       color = NULL) +
  theme(legend.position = c(.15, .15),
        legend.background = element_rect(fill = "transparent"))
```

Aqui, tamb√©m sobrescrevo o fundo da legenda branco padr√£o com um preenchimento *transparente* para garantir que a legenda n√£o oculte nenhum ponto de dados.


##### Mudar a Dire√ß√£o da Legenda

Como voc√™ viu, a dire√ß√£o da legenda √© por padr√£o vertical, mas horizontal quando voc√™ escolhe a posi√ß√£o "top" ou "bottom". Mas voc√™ tamb√©m pode mudar a dire√ß√£o como quiser:

```{r legend-orientation}

ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(legend.position = c(.5, .97),
        legend.background = element_rect(fill = "transparent")) +
  guides(color = guide_legend(direction = "horizontal"))
```


##### Mudar o Estilo do T√≠tulo da Legenda

Voc√™ pode alterar a apar√™ncia do t√≠tulo da legenda ajustando o elemento do tema `legend.title`:

```{r legend-style}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(legend.title = element_text(family = "Playfair",
                                    color = "chocolate",
                                    size = 14, face = "bold"))
```


##### Alterar t√≠tulo da legenda

A maneira mais f√°cil de alterar o t√≠tulo da legenda √© a camada `labs()`:

```{r legend-title-labs}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)",
       color = "Temporadas\nindicadas\npelas cores:") +
  theme(legend.title = element_text(family = "Playfair",
                                    color = "chocolate",
                                    size = 14, face = "bold"))
```

Os detalhes da legenda podem ser alterados via `scale_color_discrete(name = "title")` ou `guias(color = guide_legend ("title"))`:

```{r legend-title, eval=FALSE}
ggplot(chic, aes(x = date, y = temp, color = season))) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(legend.title = element_text(family = "Playfair",
                                    color = "chocolate",
                                    size = 14, face = "bold")) +
  scale_color_discrete(name = "Temporadas\nindicadas\npelas cores:")
```


##### Alterar a ordem das chaves de legenda

Podemos conseguir isso alterando os n√≠veis de `season`:

```{r legend-order}
library(haven)
f <- factor(chic$season, levels = c("Winter", "Spring", "Summer", "Autumn"))

chic <- chic %>% 
  mutate(season2 = forcats::fct_relevel(f)) 

ggplot(chic) + aes(x = date, y = temp, colour = season) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)")
```


##### Alterar R√≥tulos da Legenda

Vamos substituir as esta√ß√µes pelos meses que cobrem, fornecendo um vetor de nomes na chamada `scale_color_discrete()`:

```{r legend-labels}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  scale_color_discrete(
    name = "Esta√ß√µes:", 
    labels = c("Mar‚ÄîMai", "Jun‚ÄîAgo", "Set‚ÄîNov", "Dez‚ÄîFev")
  ) +
  theme(legend.title = element_text(
    family = "Playfair", color = "chocolate", size = 14, face = 2
  ))
```


##### Alterar caixas de fundo na legenda

Para alterar a cor de fundo (preenchimento) das chaves de legenda, ajustamos a configura√ß√£o do elemento de tema `legend.key`:

```{r legend-boxes}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(legend.key = element_rect(fill = "darkgoldenrod1"),
        legend.title = element_text(family = "Playfair",
                                    color = "chocolate",
                                    size = 14, face = 2)) +
  scale_color_discrete("Esta√ß√µes:")
```

Se voc√™ quiser se livrar deles completamente, use `fill = NA` ou `fill = "transparent"`.


##### Alterar o tamanho dos s√≠mbolos da legenda

Os pontos na legenda podem se perder um pouco com o tamanho padr√£o, especialmente sem as caixas. Para substituir o padr√£o, usa-se novamente a camada `guides` como esta:

```{r legend-symbols}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(legend.key = element_rect(fill = NA),
        legend.title = element_text(color = "chocolate",
                                    size = 14, face = 2)) +
  scale_color_discrete("Esta√ß√µes:") +
  guides(color = guide_legend(override.aes = list(size = 6))) ##
```


##### Deixe uma camada fora da legenda

Digamos que voc√™ tenha dois geoms diferentes mapeados para a mesma vari√°vel. Por exemplo, a cor como uma est√©tica para uma camada de pontos e uma camada de tapete dos mesmos dados. Por padr√£o, os pontos e a "linha" terminam na legenda assim:

```{r legend-layer-1}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  geom_rug()
```

Voc√™ pode usar `show.legend = FALSE` para desligar uma camada na legenda:

```{r legend-layer-2}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  geom_rug(show.legend = FALSE)
```


##### Adicionar itens de legenda manualmente

`{ggplot2}` n√£o adicionar√° uma legenda automaticamente a menos que voc√™ mapeie a est√©tica (color, size, etc.) para uma vari√°vel. H√° momentos, por√©m, em que quero ter uma legenda para que fique claro o que voc√™ est√° tramando.

Aqui est√° o padr√£o:

```{r legend-default-2}
ggplot(chic, aes(x = date, y = o3)) +
  geom_line(color = "gray") +
  geom_point(color = "darkorange2") +
  labs(x = "Ano", y = "Oz√¥nio")
```

Podemos for√ßar uma legenda mapeando um guia para uma *vari√°vel*. Estamos mapeando as linhas e os pontos usando `aes()` e estamos mapeando **n√£o** para uma vari√°vel em nosso conjunto de dados, mas para uma √∫nica string (de modo que obtemos apenas uma cor para cada).

```{r legend-force}
ggplot(chic, aes(x = date, y = o3)) +
  geom_line(aes(color = "line")) +
  geom_point(aes(color = "points")) +
  labs(x = "Ano", y = "Oz√¥nio") +
  scale_color_discrete("Tipo:")
```

Estamos chegando perto, mas n√£o √© isso que queremos. Queremos cinza e vermelho! Para mudar a cor, usamos `scale_color_manual()`. Al√©m disso, substitu√≠mos a est√©tica da legenda usando a fun√ß√£o `guide()`.

**Pronto!** Agora, temos um gr√°fico com linhas cinzas e pintas vermelhas, bem como uma √∫nica linha cinza e um √∫nico ponto vermelho como s√≠mbolos de legenda:

```{r legend-manual}
ggplot(chic, aes(x = date, y = o3)) +
  geom_line(aes(color = "line")) +
  geom_point(aes(color = "points")) +
  labs(x = "Ano", y = "Oz√¥nio") +
  scale_color_manual(name = NULL,
                     guide = "legend",
                     values = c("points" = "darkorange2",
                                "line" = "gray")) +
  guides(color = guide_legend(override.aes = list(linetype = c(1, 0),
                                                  shape = c(NA, 16))))
```


##### Use outros estilos de legenda

A legenda padr√£o para vari√°veis categ√≥ricas como `season` √©` guide_legend() `como voc√™ viu em v√°rios exemplos anteriores. Se voc√™ mapear uma vari√°vel cont√≠nua para uma est√©tica, `{ggplot2}` n√£o usar√°, por padr√£o, `guide_legend()`, mas `guide_colorbar()` (ou `guide_colourbar()`):

```{r legend-guide-cont-default}
ggplot(chic,
       aes(x = date, y = temp, color = temp)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)", color = "Temperatura (¬∞F)")
```

No entanto, usando `guide_legend()` voc√™ pode for√ßar a legenda a mostrar cores discretas para um determinado n√∫mero de quebras, como no caso de uma vari√°vel categ√≥rica:

```{r legend-guide-cont-legend}
ggplot(chic,
       aes(x = date, y = temp, color = temp)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)", color = "Temperatura (¬∞F)") +
  guides(color = guide_legend())
```

Voc√™ tamb√©m pode utilizar *binned scales*:

```{r legend-guide-cont-bins}
ggplot(chic,
       aes(x = date, y = temp, color = temp)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)", color = "Temperatura (¬∞F)") +
  guides(color = guide_bins())
```

... or binned scales as *discrete colorbars*:

```{r legend-guide-cont-steps}
ggplot(chic,
       aes(x = date, y = temp, color = temp)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)", color = "Temperatura (¬∞F)") +
  guides(color = guide_colorsteps())
```

[‚Üë Voltar para o √çndice.](#toc)<br><br>



## Trabalhando com Backgrounds & Linhas de Grade {#style}

Existem maneiras de mudar toda a apar√™ncia do seu enredo com uma fun√ß√£o (consulte a se√ß√£o ["Trabalhando com temas"](#temas) abaixo), mas se voc√™ quiser simplesmente mudar as cores de alguns elementos, tamb√©m pode fazer isso.


##### Alterar a cor de fundo do painel

Para alterar a cor de fundo (`fill`) da √°rea do painel (ou seja, a √°rea onde os dados s√£o plotados), √© necess√°rio ajustar o elemento de tema `panel.background`:

```{r panel-color}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "#1D8565", size = 2) +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(panel.background = element_rect(
    fill = "#64D2AA", color = "#64D2AA", size = 2)
  )
```

Observe que a cor verdadeira - o contorno do plano de fundo do painel - n√£o mudou, embora tenhamos especificado. Isso ocorre porque h√° uma camada no topo do `panel.background`, chamada` panel.border`. No entanto, certifique-se de usar um preenchimento transparente aqui, caso contr√°rio, seus dados ficar√£o ocultos atr√°s desta camada. No exemplo a seguir, ilustro isso usando uma cor hexadecimal semitransparente para o argumento `fill` em` element_rect`:

```{r panel-color-2}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "#1D8565", size = 2) +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(panel.border = element_rect(
    fill = "#64D2AA99", color = "#64D2AA", size = 2)
  )
```


##### Alterar Linhas de Grade

Existem dois tipos de linhas de grade: linhas de grade principais indicando as marcas e linhas de grade secund√°rias entre as principais. Voc√™ pode alterar tudo isso substituindo os padr√µes para `panel.grid` ou para cada conjunto de linhas de grade separadamente,` panel.grid.major` e `panel.grid.minor`.

```{r grid-lines}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(panel.grid.major = element_line(color = "gray10", size = .5),
        panel.grid.minor = element_line(color = "gray70", size = .25))
```

Voc√™ pode at√© especificar configura√ß√µes para todos os quatro n√≠veis diferentes:

```{r grid-lines-x-y}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(panel.grid.major = element_line(size = .5, linetype = "dashed"),
        panel.grid.minor = element_line(size = .25, linetype = "dotted"),
        panel.grid.major.x = element_line(color = "red1"),
        panel.grid.major.y = element_line(color = "blue1"),
        panel.grid.minor.x = element_line(color = "red4"),
        panel.grid.minor.y = element_line(color = "blue4"))
```

E, claro, voc√™ pode remover algumas ou todas as linhas de grade se desejar:

```{r grid-remove}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(panel.grid.minor = element_blank())
```

```{r grid-blank}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(panel.grid = element_blank())
```


##### Alterar espa√ßamento das linhas de grade

Al√©m disso, voc√™ tamb√©m pode definir as quebras entre as linhas de grade principais e secund√°rias:

```{r grid-breaks}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  scale_y_continuous(breaks = seq(0, 100, 10),
                     minor_breaks = seq(0, 100, 2.5))
```


##### Alterar a cor de fundo do gr√°fico

Da mesma forma, para alterar a cor de fundo (preenchimento) da √°rea de plotagem, √© necess√°rio modificar o elemento do tema `plot.background`:

```{r background-color}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(plot.background = element_rect(fill = "gray60",
                                       color = "gray30", size = 2))
```

Voc√™ pode obter uma cor de fundo exclusiva configurando as mesmas cores em `panel.background` e` plot.background` ou configurando o preenchimento do fundo do painel para `"transparente"` ou `NA`:

```{r background-color-same}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(panel.background = element_rect(fill = NA),
        plot.background = element_rect(fill = "gray60",
                                       color = "gray30", size = 2))
```

[‚Üë Voltar para o √çndice.](#toc)<br><br>



## Trabalhando com Margens {#margins}

√Äs vezes, √© √∫til adicionar um pouco de espa√ßo √† margem do gr√°fico. Semelhante aos exemplos anteriores, podemos usar um argumento para a fun√ß√£o `theme()`. Neste caso, o argumento √© `plot.margin`. Como no exemplo anterior, j√° ilustramos a margem padr√£o alterando a cor de fundo usando `plot.background`.

Agora vamos adicionar espa√ßo extra √† esquerda e √† direita. O argumento, `plot.margin`, pode lidar com uma variedade de unidades diferentes (cm, polegadas, etc.), mas requer o uso da unidade de fun√ß√£o do pacote` grade` para especificar as unidades. Voc√™ pode fornecer o mesmo valor para todos os lados (mais f√°cil via `rep(x, 4)`) ou dist√¢ncias espec√≠ficas para cada um. Aqui estou usando uma margem de 1 cm na parte superior e inferior, margem de 3 cm na direita e uma margem de 8 cm na esquerda.

```{r margin}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(plot.background = element_rect(fill = "gray60"),
        plot.margin = margin(t = 1, r = 3, b = 1, l = 8, unit = "cm"))
```

A ordem dos lados da margem √© top, right, bottom, right - uma boa maneira de lembrar essa ordem √© "**tr**ou**bl**e que classifica a primeira letra dos quatro lados.

<details>
  <summary>&#128129; <i>Voc√™ tamb√©m pode usar `unit()` ao inv√©s de  `margin()`. Expanda para ver o exemplo</i></summary>
```{r margin-2}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(plot.background = element_rect(fill = "gray60"),
        plot.margin = unit(c(1, 3, 1, 8), "cm"))
```
</details>



[‚Üë Voltar para o √çndice.](#toc)<br><br>



## Trabalhando com Gr√°ficos de v√°rios pain√©is {#panels}

O pacote `{ggplot2}` tem duas fun√ß√µes interessantes para a cria√ß√£o de gr√°ficos de m√∫ltiplos pain√©is, chamadas *facets*. Eles est√£o relacionados, mas um pouco diferentes: `facet_wrap` cria essencialmente uma faixa de gr√°ficos com base em uma √∫nica vari√°vel, enquanto` facet_grid` abrange uma grade de duas vari√°veis.


##### Crie uma grade de pequenos m√∫ltiplos com base em duas vari√°veis

No caso de duas vari√°veis, `facet_grid` faz o trabalho. Aqui, a ordem das vari√°veis determina o n√∫mero de linhas e colunas:

```{r grid-plots}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "orangered", alpha = .3) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  facet_grid(year ~ season)
```

Para alterar o arranjo de linha para coluna, voc√™ pode alterar `facet_grid(year ~ season)` para `facet_grid(season ~ year)`.


##### Criar pequenos m√∫ltiplos com base em uma vari√°vel

`facet_wrap` cria uma faceta de uma √∫nica vari√°vel, escrita com um til na frente:`facet_wrap(~ vari√°vel)`. A apar√™ncia desses subplots √© controlada pelos argumentos `ncol` e `nrow`:

```{r wrap-plots-1-row}
g <- 
  ggplot(chic, aes(x = date, y = temp)) +
    geom_point(color = "chartreuse4", alpha = .3) +
    labs(x = "Ano", y = "Temperatura (¬∞F)") +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
g + facet_wrap(~ year)
```
Assim, voc√™ pode organizar os gr√°ficos como quiser, em vez de uma matriz em uma linha ...

```{r wrap-plots-2-rows}
g + facet_wrap(~ year, nrow = 1)
```

... ou mesmo como uma grade assim√©trica de parcelas:

```{r wrap-plots-2-rows-3-col}
g + facet_wrap(~ year, ncol = 3) + theme(axis.title.x = element_text(hjust = .15))
```


##### Permitir que os eixos circulem livremente

O padr√£o para gr√°ficos de m√∫ltiplos pain√©is em `{ggplot2}` √© usar escalas equivalentes em cada painel. Mas √†s vezes voc√™ deseja permitir que os pr√≥prios dados do painel determinem a escala. Freq√ºentemente, isso n√£o √© uma boa ideia, pois pode dar ao usu√°rio uma impress√£o errada sobre os dados. Mas √†s vezes √© realmente √∫til e para fazer isso voc√™ pode definir `escalas = "free"`:

```{r wrap-plots-scales-free}
g + facet_wrap(~ year, nrow = 2, scales = "free")
```

Observe que os eixos x e y diferem em seu intervalo!


#### Use `facet_wrap` com duas vari√°veis

A fun√ß√£o `facet_wrap` tamb√©m pode levar duas vari√°veis:

```{r wrap-plots-two-vars, fig.height=7}
g + facet_wrap(year ~ season, nrow = 4, scales = "free_x")
```

Ao usar `facet_wrap`, voc√™ ainda √© capaz de controlar o design da grade: voc√™ pode reorganizar o n√∫mero de plotagens por linha e coluna e tamb√©m pode deixar todos os eixos vagarem livremente. Em contraste, `facet_grid` tamb√©m receber√° um argumento `free`, mas apenas o deixar√° livre por coluna ou linha:

```{r grid-plots-two-vars, fig.height=7}
g + facet_grid(year ~ season, scales = "free_x")
```



##### Modificar estilo de textos de tira

Usando `theme`, voc√™ pode modificar a apar√™ncia do texto da tira (ou seja, o t√≠tulo de cada faceta) e das caixas de texto da tira:

```{r facet-modify-striptext, fig.height=3.5}
g + facet_wrap(~ year, nrow = 1, scales = "free_x") +
  theme(strip.text = element_text(face = "bold", color = "chartreuse4",
                                  hjust = 0, size = 20),
        strip.background = element_rect(fill = "chartreuse3", linetype = "dotted"))
```

As seguintes [duas fun√ß√µes adaptadas desta resposta de Claus Wilke](https://stackoverflow.com/questions/60332202/conditionally-fill-ggtext-text-boxes-in-facet-wrap), o autor do [`{ ggtext} `package](https://wilkelab.org/ggtext/), permite destacar r√≥tulos espec√≠ficos em combina√ß√£o com` element_textbox() `que √© fornecido por` {ggtext} `.

```{r facet-color-striptext-function}
library(ggtext)
library(rlang)
element_textbox_highlight <- function(..., hi.labels = NULL, hi.fill = NULL,
                                      hi.col = NULL, hi.box.col = NULL, hi.family = NULL) {
  structure(
    c(element_textbox(...),
      list(hi.labels = hi.labels, hi.fill = hi.fill, hi.col = hi.col, hi.box.col = hi.box.col, hi.family = hi.family)
    ),
    class = c("element_textbox_highlight", "element_textbox", "element_text", "element")
  )
}
element_grob.element_textbox_highlight <- function(element, label = "", ...) {
  if (label %in% element$hi.labels) {
    element$fill <- element$hi.fill %||% element$fill
    element$colour <- element$hi.col %||% element$colour
    element$box.colour <- element$hi.box.col %||% element$box.colour
    element$family <- element$hi.family %||% element$family
  }
  NextMethod()
}
```

Agora voc√™ pode us√°-lo e especificar, por exemplo, todos os textos de faixa:

```{r facet-color-striptext-A, fig.height=8}
g + facet_wrap(year ~ season, nrow = 4, scales = "free_x") +
  theme(
    strip.background = element_blank(),
    strip.text = element_textbox_highlight(
      family = "Playfair", size = 12, face = "bold",
      fill = "white", box.color = "chartreuse4", color = "chartreuse4",
      halign = .5, linetype = 1, r = unit(5, "pt"), width = unit(1, "npc"),
      padding = margin(5, 0, 3, 0), margin = margin(0, 1, 3, 1),
      hi.labels = c("1997", "1998", "1999", "2000"),
      hi.fill = "chartreuse4", hi.box.col = "black", hi.col = "white"
    )
  )
```

```{r r-facet-color-striptext-B, fig.height=3.5}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(aes(color = season == "Summer"), alpha = .3) +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  facet_wrap(~ season, nrow = 1) +
  scale_color_manual(values = c("gray40", "firebrick"), guide = "none") +
  theme(
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
    strip.background = element_blank(),
    strip.text = element_textbox_highlight(
      size = 12, face = "bold",
      fill = "white", box.color = "white", color = "gray40",
      halign = .5, linetype = 1, r = unit(0, "pt"), width = unit(1, "npc"),
      padding = margin(2, 0, 1, 0), margin = margin(0, 1, 3, 1),
      hi.labels = "Summer", hi.family = "Bangers",
      hi.fill = "firebrick", hi.box.col = "firebrick", hi.col = "white"
    )
  )
```


##### Crie um painel de diferentes plotagens

Existem v√°rias maneiras de combinar os gr√°ficos. A abordagem mais f√°cil, em minha opini√£o, √© o [`{patchwork}` package](https://github.com/thomasp85/patchwork) de Thomas Lin Pedersen:

```{r combine-plots-patchwork}
p1 <- ggplot(chic, aes(x = date, y = temp,
                       color = season)) +
        geom_point() +
        geom_rug() +
        labs(x = "Ano", y = "Temperatura (¬∞F)")
p2 <- ggplot(chic, aes(x = date, y = o3)) +
        geom_line(color = "gray") +
        geom_point(color = "darkorange2") +
        labs(x = "Ano", y = "Oz√¥nio")
library(patchwork)
p1 + p2
```

Podemos alterar a ordem "dividindo" os dois gr√°ficos (e observe o alinhamento, mesmo que um tenha uma legenda e o outro n√£o!):

```{r combine-plots-patchwork-2, fig.height=8}
p1 / p2
```

E tamb√©m gr√°ficos aninhados s√£o poss√≠veis!

```{r combine-plots-patchwork-3, fig.height=6}
(g + p2) / p1
```

(Observe o alinhamento dos gr√°ficos, embora apenas um gr√°fico inclua uma legenda.)

Alternativamente, o pacote [`{cowplot}`](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html) de Claus Wilke fornece a funcionalidade para combinar v√°rios gr√°ficos (e muitos outros bons utilit√°rios):

```{r combine-plots-cowplot}
library(cowplot)
plot_grid(plot_grid(g, p1), p2, ncol = 1)
```

... e o mesmo acontece com [`{gridExtra}` package](https://cran.r-project.org/web/packages/gridExtra/vignettes/arrangeGrob.html):

```{r combine-plots-grid}
library(gridExtra)
grid.arrange(g, p1, p2,
             layout_matrix = rbind(c(1, 2), c(3, 3)))
```

A mesma ideia de definir um layout pode ser usada com `{patchwork}` que permite a cria√ß√£o de composi√ß√µes complexas:

```{r combine-plots-patchwork-layout, fig.width=12, fig.height=8}
layout <- "
AABBBB#
AACCDDE
##CCDD#
##CC###
"
p2 + p1 + p1 + g + p2 +
  plot_layout(design = layout)
```

[‚Üë Voltar para o √çndice.](#toc)<br><br>



## Trabalhando com Colors {#colors}

Para aplica√ß√µes simples, Trabalhando com cores √© direto no `{ggplot2}`. Para um tratamento mais avan√ßado do t√≥pico, voc√™ provavelmente deve colocar as m√£os no [livro de Hadley](http://www.springer.com/de/book/9780387981413#otherversion=9780387981406), que tem uma boa cobertura. Outras boas fontes s√£o o [R Cookbook](http://www.cookbook-r.com/Graphs/Colors_ (ggplot2)/) e a [`se√ß√£o de cores na R Graph Gallery](https://www.r-graph-gallery.com/ggplot2-color.html) por Yan Holtz.

Existem duas diferen√ßas principais quando se trata de cores em `{ggplot2}`. Ambos os argumentos, `color` e` fill`, podem ser

1. especificado como cor √∫nica ou
2. atribu√≠do a vari√°veis.

Como voc√™ j√° viu no in√≠cio deste tutorial, as vari√°veis que est√£o *dentro* da `aes`thetics s√£o codificadas por vari√°veis e aquelas que est√£o *fora* s√£o propriedades n√£o relacionadas √†s vari√°veis. Este gr√°fico sem sentido completo mostrando o n√∫mero de registros por ano e esta√ß√£o ilustra esse fato:

```{r inside-outside-aes}
ggplot(chic, aes(year)) +
  geom_bar(aes(fill = season), color = "grey", size = 2) +
  labs(x = "Ano", y = "Observa√ß√µes", fill = "Temporada:")
```


##### Especificar cores √∫nicas

Cores √∫nicas est√°ticas s√£o f√°ceis de usar. Podemos especificar uma √∫nica cor para um geom:

```{r color-static}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "steelblue", size = 2) +
  labs(x = "Ano", y = "Temperatura (¬∞F)")
```

... e caso forne√ßa ambos, uma `color` (cor de contorno) e um` fill` (cor de preenchimento):

```{r color-fill-static}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(shape = 21, size = 2, stroke = 1,
             color = "#3cc08f", fill = "#c08f3c") +
  labs(x = "Ano", y = "Temperatura (¬∞F)")
```

Tian Zheng, da Columbia, criou um √∫til [PDF de cores R](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf). Claro, voc√™ tamb√©m pode especificar c√≥digos de cores hexadecimais (simplesmente como strings como no exemplo acima), bem como valores RGB ou RGBA (por meio da fun√ß√£o `rgb()`: `rgb(red, green, blue, alpha)`) .


##### Atribuir cores √†s vari√°veis

Em `{ggplot2}`, as cores que s√£o atribu√≠das √†s vari√°veis s√£o modificadas por meio das fun√ß√µes `scale_color_ *` e `scale_fill_ *`. Para usar cores com seus dados, o mais importante √© saber se voc√™ est√° lidando com uma vari√°vel categ√≥rica ou cont√≠nua. A paleta de cores deve ser escolhida dependendo do tipo da vari√°vel, com paletas de cores sequenciais ou divergentes sendo usadas para vari√°veis cont√≠nuas e paletas de cores qualitativas para vari√°veis categ√≥ricas:


##### Vari√°veis Qualitativas

Vari√°veis qualitativas ou categ√≥ricas representam tipos de dados que podem ser divididos em grupos (*categorias*). A vari√°vel pode ser posteriormente especificada como nominal, ordinal e bin√°ria (dicot√¥mica). Exemplos de vari√°veis qualitativas / categ√≥ricas s√£o:

A paleta de cores categ√≥ricas padr√£o tem a seguinte apar√™ncia:

```{r color-cat-default}
(ga <- ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)", color = NULL))
```


###### Selecione manualmente as cores qualitativas

Voc√™ pode escolher seu pr√≥prio conjunto de cores e atribu√≠-las a vari√°veis categ√≥ricas por meio da fun√ß√£o `escale_*_manual()` (o `*` pode ser `color`,` colour` ou `fill`). O n√∫mero de cores especificadas deve corresponder ao n√∫mero de categorias:

```{r color-cat-manual}
ga + scale_color_manual(values = c("dodgerblue4",
                                   "darkolivegreen4",
                                   "darkorchid3",
                                   "goldenrod1"))
```


###### Use paletas de cores qualitativas integradas

As [paletas ColorBrewer](http://colorbrewer2.org/) √© uma ferramenta online popular para selecionar esquemas de cores para mapas. Os diferentes conjuntos de cores foram projetados para produzir esquemas de cores atraentes de apar√™ncia semelhante, variando de tr√™s a doze. Essas paletas est√£o dispon√≠veis como fun√ß√µes integradas no pacote `{ggplot2}` e podem ser aplicadas chamando `scale_*_brewer()`:

```{r color-brewer}
ga + scale_color_brewer(palette = "Set1")
```

üí° **Voc√™ pode explorar todos os esquemas dispon√≠veis via `RColorBrewer::display.brewer.all()`.**

###### Use paletas de cores qualitativas de pacotes de extens√£o

Existem muitos pacotes de extens√£o que fornecem paletas de cores adicionais. Seu uso difere dependendo da forma como a embalagem √© projetada. Para uma ampla vis√£o geral das paletas de cores dispon√≠veis em R, verifique a [cole√ß√£o fornecida por Emil Hvitfeldt](https://github.com/EmilHvitfeldt/r-color-palettes/blob/master/README.md#comprehensive-list-of -color-palettes-in-r). Tamb√©m se pode usar seu pacote [`{paletteer}`](https://github.com/EmilHvitfeldt/paletteer), uma cole√ß√£o abrangente de paletas de cores em R que usa uma sintaxe consistente.

**Exemplos:**

O pacote [`{ggthemes}`](https://jrnold.github.io/ggthemes/), por exemplo, permite que os usu√°rios R acessem as cores do Tableau. Tableau √© um software de visualiza√ß√£o famoso com uma [paleta de cores conhecida](http://www.tableau.com/de-de/about/blog/2016/7/colors-upgrade-tableau-10-56782).
```{r color-tableau}
library(ggthemes)
ga + scale_color_tableau()
```

O [`{ggsci}` pacote](https://cran.r-project.org/web/packages/ggsci/vignettes/ggsci.html) fornece jornais cient√≠ficos e paletas de cores com temas de fic√ß√£o cient√≠fica. Quer ter um enredo com cores que parecem estar sendo publicado na *Science* ou *Nature*? Aqui est√°!

```{r color-science-nature, fig.width=10}
library(ggsci)
g1 <- ga + scale_color_aaas()
g2 <- ga + scale_color_npg()
library(patchwork)
(g1 + g2) * theme(legend.position = "top")
```


##### Vari√°veis Quantitativas

As vari√°veis quantitativas representam uma quantidade mensur√°vel e, portanto, s√£o num√©ricas. Os dados quantitativos podem ser classificados como cont√≠nuos (n√∫meros flutuantes poss√≠veis) ou discretos (apenas n√∫meros inteiros):

Em nosso exemplo, vamos mudar a vari√°vel que queremos colorir para Oz√¥nio, uma vari√°vel cont√≠nua que est√° fortemente relacionada √† temperatura (temperatura mais alta = Oz√¥nio mais alto). A fun√ß√£o `scale_*_gradient()` √© um gradiente sequencial enquanto `scale_*_gradient2()` diverge.

Aqui est√° o esquema de cores sequencial padr√£o `{ggplot2}` para vari√°veis cont√≠nuas:

```{r colors-seq}
gb <- ggplot(chic, aes(x = date, y = temp, color = temp)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)", color = "Temperature (¬∞F):")
gb + scale_color_continuous()
```

Este c√≥digo produz o mesmo gr√°fico:

```{r colors-seq-alt, eval=FALSE}
gb + scale_color_gradient()
```

E aqui est√° o esquema de cores padr√£o divergente:

```{r colors-seq-alt-2}
mid <- mean(chic$temp)  ## midpoint
gb + scale_color_gradient2(midpoint = mid)
```


###### Definir manualmente um esquema de cores sequenciais

Voc√™ pode definir manualmente a altera√ß√£o gradual das paletas de cores para vari√°veis cont√≠nuas via `scale_*_gradient()`:

```{r scale-color-gradient}
gb + scale_color_gradient(low = "darkkhaki",
                          high = "darkgreen")
```

Os dados de temperatura s√£o normalmente distribu√≠dos, ent√£o que tal um esquema de cores divergentes (em vez de sequencial) ... Para cores divergentes, voc√™ pode usar a fun√ß√£o `scale_*_gradient2()`:

```{r scale-color-gradient2}
gb + scale_color_gradient2(midpoint = mid, low = "#dd8a0b",
                           mid = "grey92", high = "#32a676")
```


###### A bela paleta de cores de Viridis

As [**viridis** paletas de cores](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) n√£o apenas tornam seus gr√°ficos bonitos e bons para percebem, mas tamb√©m s√£o mais f√°ceis de ler por aqueles com daltonismo e imprimem bem em escala de cinza.
Voc√™ pode testar como seus gr√°ficos podem aparecer sob v√°rias formas de daltonismo usando o pacote [`dichromate`](https://cran.r-project.org/web/packages/dichromat/index.html).

E eles tamb√©m v√™m agora fornecidos com `{ggplot2}`! O gr√°fico de v√°rios pain√©is a seguir ilustra tr√™s das quatro paletas de viridis:

```{r viridis-continuous, fig.width=12, fig.height=7}
p1 <- gb + scale_color_viridis_c() + ggtitle("'viridis' (default)")
p2 <- gb + scale_color_viridis_c(option = "inferno") + ggtitle("'inferno'")
p3 <- gb + scale_color_viridis_c(option = "plasma") + ggtitle("'plasma'")
p4 <- gb + scale_color_viridis_c(option = "cividis") + ggtitle("'cividis'")
library(patchwork)
(p1 + p2 + p3 + p4) * theme(legend.position = "bottom")
```

Tamb√©m √© poss√≠vel usar as paletas de cores viridis para vari√°veis discretas:

```{r viridis-discrete}
ga + scale_color_viridis_d(guide = "none")
```


###### Use paletas de cores quantitativas de pacotes de extens√£o

Os muitos pacotes de extens√£o fornecem n√£o apenas paletas de cores categ√≥ricas adicionais, mas tamb√©m paletas sequenciais, divergentes e at√© c√≠clicas. Mais uma vez, indico a excelente [cole√ß√£o fornecida por Emil Hvitfeldt](https://github.com/EmilHvitfeldt/r-color-palettes/blob/master/README.md#comprehensive-list-of-color-palettes- in-r) para uma vis√£o geral.

**Exemplos:**

Os [`{rcartocolors}` pacotes](https://github.com/Nowosad/rcartocolor) portam os lindos [CARTOcolors](https://www.google.com/search?client=firefox-b-d&q=carto + oclors) para `{ggplot2}` e cont√©m v√°rias das minhas paletas mais usadas:

```{r color-carto, fig.width=10}
library(rcartocolor)
g1 <- gb + scale_color_carto_c(palette = "BurgYl")
g2 <- gb + scale_color_carto_c(palette = "Earth")
(g1 + g2) * theme(legend.position = "bottom")
```

O pacote [`{scico}`](https://github.com/thomasp85/scico) fornece acesso √†s [paletas de cores desenvolvidas por Fabio Crameri](http://www.fabiocrameri.ch/colourmaps.php). Essas paletas de cores n√£o s√£o apenas bonitas e frequentemente incomuns, mas tamb√©m uma boa escolha, uma vez que foram desenvolvidas para serem perceptivamente uniformes e ordenadas. Al√©m disso, eles funcionam para pessoas com defici√™ncia de vis√£o de cores e em tons de cinza:

```{r color-scico, fig.width=10}
library(scico)
g1 <- gb + scale_color_scico(palette = "berlin")
g2 <- gb + scale_color_scico(palette = "hawaii", direction = -1)
(g1 + g2) * theme(legend.position = "bottom")
```


#### Modificar paletas de cores posteriormente

Desde a √∫ltima vers√£o do `ggplot2 3.0.0`, pode-se modificar a est√©tica das camadas ap√≥s terem sido mapeadas para os dados. Ou como o `{ggplot2}` diz: "Use` after_scale() `para sinalizar a avalia√ß√£o do mapeamento ap√≥s os dados terem sido escalados."

Ent√£o, por que n√£o usar as cores modificadas em primeiro lugar? Uma vez que `{ggplot2}` s√≥ pode lidar com uma escala de `color` e uma escala de `fill`, esta √© uma funcionalidade interessante. Observe o exemplo a seguir, onde usamos `invert_color()` do pacote [`{ggdark}`](https://github.com/nsgrantham/ggdark):

```{r aftercale}
library(ggdark)
ggplot(chic, aes(date, temp, color = temp)) +
  geom_point(size = 5) +
  geom_point(aes(color = temp,
                 color = after_scale(invert_color(color))),
             size = 2) +
  scale_color_scico(palette = "hawaii", guide = "none") +
  labs(x = "Ano", y = "Temperatura (¬∞F)")
```

Alterar o esquema de cores depois √© especialmente divertido com fun√ß√µes dos pacotes `{ggdark}` e `{colorspace}`, nomeadamente `invert_color()`, `lighten()`, `darken()` e `desature()`. Voc√™ pode at√© combinar essas fun√ß√µes. Aqui, tra√ßamos um gr√°fico de caixa que tem ambos os argumentos, `color` e` fill`:

```{r aftercale-comb}
library(colorspace)
ggplot(chic, aes(date, temp)) +
  geom_boxplot(aes(color = season,
                   fill = after_scale(desaturate(lighten(color, .6), .6))),
               size = 1) +
  scale_color_brewer(palette = "Dark2", guide = "none") +
  labs(x = "Ano", y = "Temperatura (¬∞F)")
```

Note que voc√™ precisa especificar a `color` e / ou `fill` em `aes()` do respectivo `geom_*()` ou `stat_*()` para fazer `after_scale()` funcionar.

üí° **Isso parece um pouco complicado por enquanto - pode-se simplesmente usar as escalas `color` e` fill` para ambos. Sim, isso √© verdade, mas pense nos casos de uso em que voc√™ precisa de v√°rias escalas de `color` e / ou `fill`. Nesse caso, n√£o faria sentido ocupar a escala de `fill` com uma vers√£o ligeiramente mais escura da paleta usada para `color`.**

[‚Üë Voltar para o √çndice.](#toc)<br><br>



## Trabalhando com Themes {#themes}

##### Alterar o estilo geral de plotagem

Voc√™ pode alterar toda a apar√™ncia das plotagens usando temas. `{ggplot2}` vem com oito temas integrados:

```{r ggplot2-theme-gallery, echo=FALSE, purl=FALSE, fig.width=11, fig.height=7}
p <- ggplot(chic, aes(x = date, y = temp)) +
       geom_point(color = "gray30", alpha = .3) +
       labs(x = "Ano", y = "Temperatura (¬∞F)")
p1 <- p + theme_gray() + ggtitle("theme_gray()")
p2 <- p + theme_bw() + ggtitle("theme_bw()")
p3 <- p + theme_classic() + ggtitle("theme_classic()")
p4 <- p + theme_dark() + ggtitle("theme_dark()")
p5 <- p + theme_light() + ggtitle("theme_light()")
p6 <- p + theme_linedraw() + ggtitle("theme_linedraw()")
p7 <- p + theme_minimal() + ggtitle("theme_minimal()")
p8 <- p + theme_void() + ggtitle("theme_void()") + theme(plot.title = element_text(color = "black", margin = margin(b = 11/2)))
font_add_google("Roboto Mono", "Roboto Mono")
(p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8) *
  theme(plot.title = element_text(family = "Roboto Mono", hjust = .5, face = "bold", size = 16),
        plot.margin = margin(rep(15, 5))) +
  plot_layout(ncol = 4)
```


Existem v√°rios pacotes que fornecem temas adicionais, alguns at√© com diferentes paletas de cores padr√£o. Como exemplo, Jeffrey Arnold reuniu a biblioteca `{ggthemes}` com v√°rios temas personalizados que imitam designs populares. Para obter uma lista, voc√™ pode visitar o [`{ggthemes}` site do pacote](https://github.com/jrnold/ggthemes). Sem qualquer codifica√ß√£o, voc√™ pode apenas adaptar v√°rios estilos, alguns deles bem conhecidos por seu estilo e est√©tica.

Aqui est√° um exemplo copiando o [estilo de plotagem](https://www.google.de/search?q=economist+graphic&tbm=isch) na revista [The Economist](http://www.economist.com/) usando `theme_economist()` e `scale_color_economist()`:

```{r Economist}
library(ggthemes)
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  ggtitle("Altos e baixos das temperaturas di√°rias de Chicago") +
  theme_economist() +
  scale_color_economist(name = NULL)
```

Outro exemplo √© o estilo de plotagem de Tufte, um tema minimalista de tinta baseado no livro de [Edward Tufte](http://wwww.aiga.org/medalist-edwardtufte) [The Visual Display of Quantitative Information](https://www.edwardtufte.com/tufte/books_vdqi). Este √© o livro que popularizou [o gr√°fico de Minard representando a marcha de Napole√£o na R√∫ssia](https://www.edwardtufte.com/tufte/minard) como um dos **melhores desenhos estat√≠sticos j√° criados **. Os enredos de Tufte ficaram famosos devido ao purismo de seu estilo. Mas veja voc√™ mesmo:

```{r Tufte}
library(dplyr)
chic_2000 <- filter(chic, year == 2000)
ggplot(chic_2000, aes(x = temp, y = o3)) +
  geom_point() +
  labs(x = "Temperatura (¬∞F)", y = "Oz√¥nio") +
  ggtitle("N√≠veis de temperatura e oz√¥nio durante o ano de 2000 em Chicago") +
  theme_tufte()
```

Reduzi o n√∫mero de pontos de dados aqui simplesmente para se ajustar ao estilo minimalista de Tufte. Se voc√™ gosta da maneira de plotar, d√™ uma olhada em [esta entrada do blog](http://motioninsocial.com/tufte/) como criar v√°rios plots de Tufte em R.

Outro pacote bacana com temas modernos e uma predefini√ß√£o de fontes n√£o padr√£o √© o pacote [`{hrbrthemes}` de Bob Rudis](https://github.com/hrbrmstr/hrbrthemes) com v√°rios temas claros, mas tamb√©m escuros:

```{r hrbrthemes, echo=-5}
library(hrbrthemes)
ggplot(chic, aes(x = temp, y = o3)) +
  geom_point(aes(color = dewpoint), show.legend = FALSE) +
  labs(x = "Temperatura (¬∞F)", y = "Oz√¥nio") +
  ggtitle("N√≠veis de temperatura e oz√¥nio em Chicago")
update_geom_defaults("point", list(colour = "black"))
```


##### Alterar a fonte de todos os elementos de texto

√â incrivelmente f√°cil alterar as configura√ß√µes de todos os elementos de texto de uma vez. Todos os temas v√™m com um argumento chamado `base_family`:

```{r theme-base-text-family}
g <- ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)",
       title = "Temperaturas em Chicago")
g + theme_bw(base_family = "Playfair")
```


##### Alterar o tamanho de todos os elementos de texto

As fun√ß√µes `theme_*()` tamb√©m v√™m com v√°rios outros argumentos `base_*`. Se voc√™ olhar mais de perto o tema padr√£o (consulte o cap√≠tulo "Criar e usar seu tema personalizado" abaixo), voc√™ notar√° que os tamanhos de todos os elementos s√£o relativos `(rel())` ao `base_size`. Como resultado, voc√™ pode simplesmente alterar o `base_size` se quiser aumentar a legibilidade de seus gr√°ficos:

```{r theme-base-text-size}
g + theme_bw(base_size = 30, base_family = "Roboto Condensed")
```


##### Alterar o tamanho de todas as linhas e elementos retos

Da mesma forma, voc√™ pode alterar o tamanho de todos os elementos do tipo `line` e` rect`:

```{r theme-base-line-size}
g + theme_bw(base_line_size = 1, base_rect_size = 1)
```


##### Crie seu pr√≥prio tema

Se voc√™ quiser mudar o tema para uma sess√£o inteira, voc√™ pode usar `theme_set` como em` theme_set(theme_bw()) `. O padr√£o √© chamado `theme_gray` (ou`theme_gray`). Se voc√™ quiser criar seu pr√≥prio tema personalizado, poder√° extrair o c√≥digo diretamente do tema cinza e modific√°-lo. Observe que a fun√ß√£o `rel()` altera os tamanhos em rela√ß√£o ao `base_size`.
```{r theme-default}
theme_gray
```

Agora, vamos modificar a fun√ß√£o do tema padr√£o e dar uma olhada no resultado:

```{r theme-mods, results="hide"}
theme_custom <- function (base_size = 12, base_family = "Roboto Condensed") {
  half_line <- base_size/2
  theme(
    line = element_line(color = "black", size = .5,
                        linetype = 1, lineend = "butt"),
    rect = element_rect(fill = "white", color = "black",
                        size = .5, linetype = 1),
    text = element_text(family = base_family, face = "plain",
                        color = "black", size = base_size,
                        lineheight = .9, hjust = .5, vjust = .5,
                        angle = 0, margin = margin(), debug = FALSE),
    axis.line = element_blank(),
    axis.line.x = NULL,
    axis.line.y = NULL,
    axis.text = element_text(size = base_size * 1.1, color = "gray30"),
    axis.text.x = element_text(margin = margin(t = .8 * half_line/2),
                               vjust = 1),
    axis.text.x.top = element_text(margin = margin(b = .8 * half_line/2),
                                   vjust = 0),
    axis.text.y = element_text(margin = margin(r = .8 * half_line/2),
                               hjust = 1),
    axis.text.y.right = element_text(margin = margin(l = .8 * half_line/2),
                                     hjust = 0),
    axis.ticks = element_line(color = "gray30", size = .7),
    axis.ticks.length = unit(half_line / 1.5, "pt"),
    axis.ticks.length.x = NULL,
    axis.ticks.length.x.top = NULL,
    axis.ticks.length.x.bottom = NULL,
    axis.ticks.length.y = NULL,
    axis.ticks.length.y.left = NULL,
    axis.ticks.length.y.right = NULL,
    axis.title.x = element_text(margin = margin(t = half_line),
                                vjust = 1, size = base_size * 1.3,
                                face = "bold"),
    axis.title.x.top = element_text(margin = margin(b = half_line),
                                    vjust = 0),
    axis.title.y = element_text(angle = 90, vjust = 1,
                                margin = margin(r = half_line),
                                size = base_size * 1.3, face = "bold"),
    axis.title.y.right = element_text(angle = -90, vjust = 0,
                                      margin = margin(l = half_line)),
    legend.background = element_rect(color = NA),
    legend.spacing = unit(.4, "cm"),
    legend.spacing.x = NULL,
    legend.spacing.y = NULL,
    legend.margin = margin(.2, .2, .2, .2, "cm"),
    legend.key = element_rect(fill = "gray95", color = "white"),
    legend.key.size = unit(1.2, "lines"),
    legend.key.height = NULL,
    legend.key.width = NULL,
    legend.text = element_text(size = rel(.8)),
    legend.text.align = NULL,
    legend.title = element_text(hjust = 0),
    legend.title.align = NULL,
    legend.position = "right",
    legend.direction = NULL,
    legend.justification = "center",
    legend.box = NULL,
    legend.box.margin = margin(0, 0, 0, 0, "cm"),
    legend.box.background = element_blank(),
    legend.box.spacing = unit(.4, "cm"),
    panel.background = element_rect(fill = "white", color = NA),
    panel.border = element_rect(color = "gray30",
                                fill = NA, size = .7),
    panel.grid.major = element_line(color = "gray90", size = 1),
    panel.grid.minor = element_line(color = "gray90", size = .5,
                                    linetype = "dashed"),
    panel.spacing = unit(base_size, "pt"),
    panel.spacing.x = NULL,
    panel.spacing.y = NULL,
    panel.ontop = FALSE,
    strip.background = element_rect(fill = "white", color = "gray30"),
    strip.text = element_text(color = "black", size = base_size),
    strip.text.x = element_text(margin = margin(t = half_line,
                                                b = half_line)),
    strip.text.y = element_text(angle = -90,
                                margin = margin(l = half_line,
                                                r = half_line)),
    strip.text.y.left = element_text(angle = 90),
    strip.placement = "inside",
    strip.placement.x = NULL,
    strip.placement.y = NULL,
    strip.switch.pad.grid = unit(0.1, "cm"),
    strip.switch.pad.wrap = unit(0.1, "cm"),
    plot.background = element_rect(color = NA),
    plot.title = element_text(size = base_size * 1.8, hjust = .5,
                              vjust = 1, face = "bold",
                              margin = margin(b = half_line * 1.2)),
    plot.title.position = "panel",
    plot.subtitle = element_text(size = base_size * 1.3,
                                 hjust = .5, vjust = 1,
                                 margin = margin(b = half_line * .9)),
    plot.caption = element_text(size = rel(0.9), hjust = 1, vjust = 1,
                                margin = margin(t = half_line * .9)),
    plot.caption.position = "panel",
    plot.tag = element_text(size = rel(1.2), hjust = .5, vjust = .5),
    plot.tag.position = "topleft",
    plot.margin = margin(base_size, base_size, base_size, base_size),
    complete = TRUE
  )
}
```

üí° **Voc√™ s√≥ pode sobrescrever os padr√µes de todos os elementos que deseja alterar. Aqui listei tudo para que voc√™ possa ver que pode mudar *literalmente* mudar tudo! **

D√™ uma olhada na est√©tica modificada com sua nova apar√™ncia de painel e linhas de grade, bem como sinais de eixos, textos e t√≠tulos:

```{r theme-set}
theme_set(theme_custom())
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() + labs(x = "Ano", y = "Temperatura (¬∞F)") + guides(color = FALSE)
```

**Esta forma de alterar o desenho do gr√°fico √© altamente recomendada!**

Ela permite que voc√™ altere rapidamente qualquer elemento de seus lotes, alterando-o uma vez. Voc√™ pode em poucos segundos plotar todos os seus resultados em um estilo congruente e adapt√°-lo a outras necessidades (por exemplo, uma apresenta√ß√£o com tamanho de fonte maior ou requisitos de peri√≥dico).


##### Atualizar o tema atual

Voc√™ tamb√©m pode definir mudan√ßas r√°pidas usando `theme_update()`:

```{r theme-update}
theme_custom <- theme_update(panel.background = element_rect(fill = "gray60"))
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() + labs(x = "Ano", y = "Temperatura (¬∞F)") + guides(color = FALSE)
```

Para exerc√≠cios posteriores, usaremos nosso pr√≥prio tema com preenchimento branco e sem as linhas de grade secund√°rias:

```{r theme-reset}
theme_custom <- theme_update(panel.background = element_rect(fill = "white"),
                             panel.grid.major = element_line(size = .5),
                             panel.grid.minor = element_blank())
```

[‚Üë Voltar para o √çndice.](#toc)<br><br>



## Trabalhando com Linhas {#lines}

##### Adicionar linhas horizontais ou verticais a um gr√°fico

Voc√™ pode querer destacar um determinado intervalo ou limite, o que pode ser feito tra√ßando uma linha em coordenadas definidas usando `geom_hline()` (para "linhas horizontais") ou `geom_vline()` (para "linhas verticais"):

```{r hline}
ggplot(chic, aes(x = date, y = temp, color = o3)) +
  geom_point() +
  geom_hline(yintercept = c(0, 73)) +
  labs(x = "Ano", y = "Temperatura (¬∞F)")
```

```{r vline}
g <- ggplot(chic, aes(x = temp, y = dewpoint)) +
  geom_point(color = "dodgerblue", alpha = .5) +
  labs(x = "Temperatura (¬∞F)", y = "Dewpoint")
g +
  geom_vline(aes(xintercept = median(temp)), size = 1.5,
             color = "firebrick", linetype = "dashed") +
  geom_hline(aes(yintercept = median(dewpoint)), size = 1.5,
             color = "firebrick", linetype = "dashed")
```

Se voc√™ quiser adicionar uma linha com uma inclina√ß√£o que n√£o seja 0 ou 1, respectivamente, voc√™ precisa usar `geom_abline()`. Este √© o caso, por exemplo, se voc√™ deseja adicionar uma linha de regress√£o usando os argumentos `interceptar` e` inclina√ß√£o`:

```{r abline}
reg <- lm(dewpoint ~ temp, data = chic)
g +
  geom_abline(intercept = coefficients(reg)[1],
              slope = coefficients(reg)[2],
              color = "darkorange2", size = 1.5) +
  labs(title = paste0("y = ", round(coefficients(reg)[2], 2),
                      " * x + ", round(coefficients(reg)[1], 2)))
```

Mais tarde, aprenderemos como adicionar um ajuste linear com um comando usando `stat_smooth(method = "lm")`. No entanto, pode haver outras raz√µes para adicionar uma linha com uma determinada inclina√ß√£o e √© assim que se faz ü§∑

##### Adicionar uma linha dentro de um gr√°fico

As abordagens anteriores sempre cobriram toda a gama do painel de plotagem, mas √†s vezes queremos destacar apenas uma determinada √°rea ou usar linhas para anota√ß√µes. Neste caso, `geom_linerange()` est√° aqui para ajudar:

```{r linerange}
g +
  ## vertical line
  geom_linerange(aes(x = 50, ymin = 20, ymax = 55),
                 color = "steelblue", size = 2) +
  ## horizontal line
  geom_linerange(aes(xmin = -Inf, xmax = 25, y = 0),
                 color = "red", size = 1)
```

Ou voc√™ pode usar `geom_segment()` para desenhar linhas com uma inclina√ß√£o diferente de 0 e 1:

```{r segment}
g +
  geom_segment(aes(x = 50, xend = 75,
                   y = 20, yend = 45),
               color = "purple", size = 2)
```


##### Adicionar linhas curvas e setas a um gr√°fico

`geom_curve()` adiciona curvas. Bem, e linhas retas se voc√™ quiser:

```{r curve}
g +
  geom_curve(aes(x = 0, y = 60, xend = 75, yend = 0),
             size = 2, color = "tan") +
  geom_curve(aes(x = 0, y = 60, xend = 75, yend = 0),
             curvature = -0.7, angle = 45,
             color = "darkgoldenrod1", size = 1) +
  geom_curve(aes(x = 0, y = 60, xend = 75, yend = 0),
             curvature = 0, size = 1.5)
```

O mesmo geom pode ser usado para desenhar setas:

```{r arrows}
g +
  geom_curve(aes(x = 0, y = 60, xend = 75, yend = 0),
             size = 2, color = "tan",
             arrow = arrow(length = unit(0.07, "npc"))) +
  geom_curve(aes(x = 5, y = 55, xend = 70, yend = 5),
             curvature = -0.7, angle = 45,
             color = "darkgoldenrod1", size = 1,
             arrow = arrow(length = unit(0.03, "npc"),
                           type = "closed",
                           ends = "both"))
```

[‚Üë Voltar para o √çndice.](#toc)<br><br>



## Trabalhando com Text {#text}

##### Add Labels to Your Data

Sometimes, we want to label our data points. To avoid overlaying and crowding by text labels, we use a 1% sample of the original data, equally representing the four seasons. We are using `geom_label()` which comes with a new aesthetic called `label`:

```{r data-text}
set.seed(2020)
library(dplyr)
sample <- chic %>%
  dplyr::group_by(season) %>%
  dplyr::sample_frac(0.01)
## code without pipes:
## sample <- sample_frac(group_by(chic, season), .01)
ggplot(sample, aes(x = date, y = temp, color = season)) +
  geom_point() +
  geom_label(aes(label = season), hjust = .5, vjust = -.5) +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  xlim(as.Date(c('1997-01-01', '2000-12-31'))) +
  ylim(c(0, 90)) +
  theme(legend.position = "none")
```

Okay, avoiding overlap of labels did not work out. But don't worry, we are going to fix it in a minute!

<details>
  <summary>&#128129; <i>You can also use `geom_text()` if you don't like boxes around your labels. Expand to see example.</i></summary>
```{r data-label}
ggplot(sample, aes(x = date, y = temp, color = season)) +
  geom_point() +
  geom_text(aes(label = season), fontface = "bold",
            hjust = .5, vjust = -.25) +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  xlim(as.Date(c('1997-01-01', '2000-12-31'))) +
  ylim(c(0, 90)) +
  theme(legend.position = "none")
```
</details>

A cool thing is the `{ggrepel}` package which provides geoms for `{ggplot2}` to repel overlapping text as in our examples above. We simply replace `geom_text()` by `geom_text_repel()` and `geom_label()` by `geom_label_repel()`:

```{r ggrepel}
library(ggrepel)
ggplot(sample, aes(x = date, y = temp, color = season)) +
  geom_point() +
  geom_label_repel(aes(label = season), fontface = "bold") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(legend.position = "none")
```

It may look nicer with filled boxes so we map `season` to `fill` instead to `color` and set a white color for the text:

```{r ggrepel-filled}
ggplot(sample, aes(x = date, y = temp)) +
  geom_point(data = chic, size = .5) +
  geom_point(aes(color = season), size = 1.5) +
  geom_label_repel(aes(label = season, fill = season),
                   color = "white", fontface = "bold",
                   segment.color = "grey30") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(legend.position = "none")
```

This also works for the pure text labels by using `geom_text_repel()`. Have a look at all the [usage examples](https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html).

##### Add Text Annotations

There are several ways how one can add annotations to a ggplot. We can again use `geom_text()` or `geom_label()`:

```{r textbox-label}
g <-
  ggplot(chic, aes(x = temp, y = dewpoint)) +
  geom_point(alpha = .5) +
  labs(x = "Temperatura (¬∞F)", y = "Dewpoint")
g +
  geom_text(aes(x = 25, y = 60,
                label = "This is a useful annotation"))
```

However, now ggplot has drawn one text label per data point‚Äîthat's 1,461 labels and you only see one! You can solve that by setting the `stat` argument to `"unique"`:

```{r textbox-label-unique}
g +
  geom_text(aes(x = 25, y = 60,
                label = "This is a useful annotation"),
            stat = "unique")
```

By the way, of course one can change the properties of the displayed text:

```{r textbox-label-custom}
g +
  geom_text(aes(x = 25, y = 60,
                label = "This is a useful annotation"),
            stat = "unique", family = "Bangers",
            size = 7, color = "darkcyan")
```

In case you use one of the facet functions to visualize your data you might run into trouble. One thing is that you may want to include the annotation only once:

```{r label-facet-single}
ann <- data.frame(
  o3 = 30,
  temp = 20,
  season = factor("Summer", levels = levels(chic$season)),
  label = "Here is enough space\nfor some annotations."
)
g <-
  ggplot(chic, aes(x = o3, y = temp)) +
  geom_point() +
  labs(x = "Oz√¥nio", y = "Temperatura (¬∞F)")
g +
  geom_text(data = ann, aes(label = label),
            size = 7, fontface = "bold",
            family = "Roboto Condensed") +
  facet_wrap(~season)
```

Another challenge are facets in combination with free scales that might cut your text:

```{r label-facet-scales-problem}
g +
  geom_text(aes(x = 23, y = 97,
                label = "This is not a useful annotation"),
            size = 5, fontface = "bold") +
  scale_y_continuous(limits = c(NA, 100)) +
  facet_wrap(~season, scales = "free_x")
```

One solution is to calculate the midpoint of the axis, here `x`, beforehand:

```{r label-facet-scales-problem-solved-prep}
library(tidyverse)
(ann <-
  chic %>%
  group_by(season) %>%
  summarize(o3 = min(o3, na.rm = TRUE) +
              (max(o3, na.rm = TRUE) - min(o3, na.rm = TRUE)) / 2))
ann
```

... and use the aggreated data to specify the placement of the annotation:

```{r label-facet-scales-problem-solved-plot}
g +
  geom_text(data = ann,
            aes(x = o3, y = 97,
                label = "This is a useful annotation"),
            size = 5, fontface = "bold") +
  scale_y_continuous(limits = c(NA, 100)) +
  facet_wrap(~season, scales = "free_x")
```

However, there is a simpler approach (in terms of fixing the cordinates)‚Äîbut it also takes a while to know the code by heart. The `{grid}` package in combination with `{ggplot2}`'s `annotation_custom()` allows you to specify the location based on scaled coordinates where 0 is low and 1 is high. `grobTree()` creates a grid graphical object and `textGrob` creates the text graphical object. The value of this is particularly evident when you have multiple plots with different scales.

```{r grobTree}
library(grid)
my_grob <- grobTree(textGrob("This text stays in place!",
                             x = .1, y = .9, hjust = 0,
                             gp = gpar(col = "black",
                                       fontsize = 15,
                                       fontface = "bold")))
g +
  annotation_custom(my_grob) +
  facet_wrap(~season, scales = "free_x") +
  scale_y_continuous(limits = c(NA, 100))
```


##### Use Markdown and HTML Rendering for Annotations

Again, we are using Claus Wilke's [`{ggtext}` package](https://wilkelab.org/ggtext/) that is designed for improved text rendering support for `{ggplot2}`. The `{ggtext}` package defines two new theme elements, `element_markdown()` and `element_textbox()`. The package also provides additional geoms. `geom_richtext()` is a replacement for `geom_text()` and `geom_label()` and renders text as markdown...

```{r ggtext-geom-richtext-md}
library(ggtext)
lab_md <- "This plot shows **temperature** in *¬∞F* versus **Oz√¥nio level** in *ppm*"
g +
  geom_richtext(aes(x = 35, y = 3, label = lab_md),
                stat = "unique")
```

... or html:

```{r ggtext-geom-richtext-html}
lab_html <- "&#9733; This plot shows <b style='color:red;'>temperature</b> in <i>¬∞F</i> versus <b style='color:blue;'>Oz√¥nio level</b>in <i>ppm</i> &#9733;"
g +
  geom_richtext(aes(x = 33, y = 3, label = lab_html),
                stat = "unique")
```

The geom comes with a lot of details one can modify, such as angle (which is not possible in the default `geom_text()` and `geom_label()`), properties of the box and properties of the text.

```{r ggtext-geom-richtext-modify}
g +
  geom_richtext(aes(x = 10, y = 25, label = lab_md),
                stat = "unique", angle = 30,
                color = "white", fill = "steelblue",
                label.color = NA, hjust = 0, vjust = 0,
                family = "Playfair Display")
```

The other geom from the `{ggtext}` package is `geom_textbox()`. This geom allows for dynamic wrapping of strings which is very useful for longer annotations such as info boxes and subtitles.

```{r ggtetxt-geom-textbox}
lab_long <- "**Lorem ipsum dolor**<br><i style='font-size:8pt;color:red;'>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.<br>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</i>"
g +
  geom_textbox(aes(x = 40, y = 10, label = lab_long),
               width = unit(15, "lines"), stat = "unique")
```

Note that it is not possible to either rotate the textbox (always horizontal) nor to change the justification of the text (always left-aligned).

[‚Üë Voltar para o √çndice.](#toc)<br><br>



## Trabalhando com Coordinates {#coords}

##### Flip a Plot

It is incredibly easy to flip a plot on its side. Here I have added the `coord_flip()` which is all you need to flip the plot. This makes most sense when using geom's to represent categorical data, for example bar charts or, as in the following example, box and whiskers plots:

```{r flip-coords}
ggplot(chic, aes(x = season, y = o3)) +
  geom_boxplot(fill = "indianred") +
  labs(x = "Season", y = "Oz√¥nio") +
  coord_flip()
```

<details>
  <summary>&#128129; <i>Since `{ggplot2}` version 3.0.0 it is also possible to draw geom's horizontally via the argument `orientation = "y"`. Expand to see example.</i></summary>
```{r flip-coords-orientation}
ggplot(chic, aes(x = o3, y = season)) +
  geom_boxplot(fill = "indianred", orientation = "y") +
  labs(x = "Oz√¥nio", y = "Season")
```
</details>


##### Fix an Axis

One can fix the aspect ratio of the Cartesian coordinate system and literally force a physical representation of the units along the x and y axes:

```{r fixed-axis-equal, fig.height=5}
ggplot(chic, aes(x = temp, y = o3)) +
  geom_point() +
  labs(x = "Temperatura (¬∞F)", y = "Oz√¥nio Level") +
  scale_x_continuous(breaks = seq(0, 80, by = 20)) +
  coord_fixed(ratio = 1)
```

This way one can ensure not only a fixed step length on the axes but also that the exported plot looks as expected. However, your saved plot likely contains a lot of white space in case you do not use a suitable aspect ratio:


```{r fixed-axis-scaled, fig.height=4.5, fig.width=9}
ggplot(chic, aes(x = temp, y = o3)) +
  geom_point() +
  labs(x = "Temperatura (¬∞F)", y = "Oz√¥nio Level") +
  scale_x_continuous(breaks = seq(0, 80, by = 20)) +
  coord_fixed(ratio = 1/3) +
  theme(plot.background = element_rect(fill = "grey80"))
```


##### Reverse an Axis

You can also easily reverse an axis using `scale_x_reverse()` or `scale_y_reverse()`, respectively:

```{r reversed-axis}
ggplot(chic, aes(x = date, y = temp, color = o3)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  scale_y_reverse()
```

<details>
  <summary>&#128129; <i>Note that this will only work for continuous data. If you want to reverse discrete data, use the `fct_rev()` function from the [{forcats} package](https://forcats.tidyverse.org/). Expand to see example.</i></summary>

```{r disc-axes}
## the default
ggplot(chic, aes(x = temp, y = season)) +
  geom_jitter(aes(color = season),
              orientation = "y", show.legend = FALSE) +
  labs(x = "Temperatura (¬∞F)", y = NULL)
```

```{r rev-disc-axes}
library(forcats)
ggplot(chic, aes(x = temp, y = fct_rev(season))) +
  geom_jitter(aes(color = season),
              orientation = "y", show.legend = FALSE) +
  labs(x = "Temperatura (¬∞F)", y = NULL)
```
</details>


##### Transform an Axis

... or transform the default linear mapping by using `scale_y_log10()` or `scale_y_sqrt()`. As an example, here is a log<sub>10</sub>-transformed axis (which introduces NA's in this case so be careful):

```{r log-axis}
ggplot(chic, aes(x = date, y = temp, color = o3)) +
  geom_point() +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  scale_y_log10(lim = c(0.1, 100))
```


##### Circularize a Plot

It is also possible to circularize (polarize?) the coordinate system by calling `coord_polar()`.

```{r polar-coords}
library(tidyverse)
chic %>%
  dplyr::group_by(season) %>%
  dplyr::summarize(o3 = median(o3)) %>%
  ggplot(aes(x = season, y = o3)) +
    geom_col(aes(fill = season), color = NA) +
    labs(x = "", y = "Median Oz√¥nio Level") +
    coord_polar() +
    guides(fill = FALSE)
```

This coordinate system allows to draw pie charts as well:

```{r pie-chart}
chic_sum <-
  chic %>%
  dplyr::mutate(o3_avg = median(o3)) %>%
  dplyr::filter(o3 > o3_avg) %>%
  dplyr::mutate(n_all = n()) %>%
  dplyr::group_by(season) %>%
  dplyr::summarize(rel = n() / unique(n_all))
ggplot(chic_sum, aes(x = "", y = rel)) +
  geom_col(aes(fill = season), width = 1, color = NA) +
  labs(x = "", y = "Proportion of Days Exceeding\nthe Median Oz√¥nio Level") +
  coord_polar(theta = "y") +
  scale_fill_brewer(palette = "Set1", name = "Season:") +
  theme(axis.ticks = element_blank(),
        panel.grid = element_blank())
```

I suggest to always look also at the outcome of the same code in a Cartesian coordinate system, which is the default, to understand the logic behind `coord_polar()` and `theta`:

```{r pie-chart-cartesian}
ggplot(chic_sum, aes(x = "", y = rel)) +
  geom_col(aes(fill = season), width = 1, color = NA) +
  labs(x = "", y = "Proportion of Days Exceeding\nthe Median Oz√¥nio Level") +
  #coord_polar(theta = "y") +
  scale_fill_brewer(palette = "Set1", name = "Season:") +
  theme(axis.ticks = element_blank(),
        panel.grid = element_blank())
```

[‚Üë Voltar para o √çndice.](#toc)<br><br>



## Trabalhando com Chart Types {#charts}

##### Alternatives to a Box Plot

Box plots are great, but they can be so incredibly boring. Also, even if you are used to looking at box plots, remember there might be plenty people looking at your plot that have never seen a box and whisker plot before.

<details>
<summary>&#128129; <i>Expand for a short recap on box and whiskers plots.</i></summary>

A box-and-whisker plot (sometimes called simply a box plot) is a histogram-like method of displaying data, invented by J. Tukey.  The thick **middle line** notates the median, also known as quartile <i>Q<sub>2</sub></i>. The limits of the **box** are determined by the lower and upper quartiles, <i>Q<sub>1</sub></i> and <i>Q<sub>3</sub></i>. The box contains thus 50% of the data and is called *"interquartile range"* (IQR). The length of the **whiskers** is determined by the most extreme values that are not considered as outliers (i.e. values that are within 3/2 times the interquartile range).<br>
![](/img/evol-ggplot/boxplot.png)
<br>
</details>

There are alternatives, but first we are plotting a common box plot:

```{r boxplot}
g <-
  ggplot(chic, aes(x = season, y = o3,
                   color = season)) +
    labs(x = "Season", y = "Oz√¥nio") +
    scale_color_brewer(palette = "Dark2", guide = "none")
g + geom_boxplot()
```


###### 1. Alternative: Plot of Points

Let's plot just each data point of the raw data:

```{r point}
g + geom_point()
```

Not only boring but uninformative. To improve the plot, one could add transparency to deal with overplotting:

```{r point-alpha}
g + geom_point(alpha = .1)
```

However, setting transparency is difficult here since either the overlap is still too high or the extreme values are not visible. Bad, so let's try something else.

###### 2. Alternative: Jitter the Points

Try adding a little jitter to the data. I like this for in-house visualization but be careful using jittering because you are purposely adding noise to your data and this can result in misinterpretation of your data.

```{r jitter}
g + geom_jitter(width = .3, alpha = .5)
```

###### 3. Alternative: Violin Plots

Violin plots, similar to box plots except you are using a kernel density to show where you have the most data, are a useful visualization.

```{r violin}
g + geom_violin(fill = "gray80", size = 1, alpha = .5)
```

###### 4. Alternative: Combining Violin Plots with Jitter

We can of course combine both, estimated densities and the raw data points:

```{r violin-jitter, fig.height=6}
g + geom_violin(fill = "gray80", size = 1, alpha = .5) +
    geom_jitter(alpha = .25, width = .3) +
    coord_flip()
```

The [`{ggforce}` package](https://ggforce.data-imaginist.com/) provides so-called sina functions where the width of the jitter is controlled by the density distribution of the data‚Äîthat makes the jittering a bit more visually appealing:

```{r violin-sina}
library(ggforce)
g + geom_violin(fill = "gray80", size = 1, alpha = .5) +
    geom_sina(alpha = .25) +
    coord_flip()
```

###### 5. Alternative: Combining Violin Plots with Box Plots

To allow for easy estimation of quantiles, we can also add the box of the box plot inside the violins to indicate 25%-quartile, median and 75%-quartile:

```{r violin-jitter-box, fig.height=6}
g + geom_violin(aes(fill = season), size = 1, alpha = .5) +
    geom_boxplot(outlier.alpha = 0, coef = 0,
                 color = "gray40", width = .2) +
    scale_fill_brewer(palette = "Dark2", guide = "none") +
    coord_flip()
```


##### Create a Rug Representation to a Plot

A rug represents the data of a single quantitative variable, displayed as marks along an axis. In most cases, it is used in addition to scatter plots or heatmaps to visualize the overall distribution of one or both of the variables:

```{r rug}
ggplot(chic, aes(x = date, y = temp,
                 color = season)) +
  geom_point(show.legend = FALSE) +
  geom_rug(show.legend = FALSE) +
  labs(x = "Ano", y = "Temperatura (¬∞F)")
```

```{r rug-2}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point(show.legend = FALSE) +
  geom_rug(sides = "r", alpha = .3, show.legend = FALSE) +
  labs(x = "Ano", y = "Temperatura (¬∞F)")
```


##### Create a Correlation Matrix

There are several packages that allow to create correlation matrix plots, some also using the`{ggplot2}` infrastructure and thus returning ggplots. I am going to show you how to do this without extension packages.

First step is to create the correlation matrix. Here, we use the `{corrr}` package that works nicely with pipes but there are also many others out there. We are using Pearson because all the variables are fairly normally distributed (but you may consider Spearman if your variables follow a different pattern). Note that since a correlation matrix has redundant information we are setting half of it to `NA`.

```{r corr-matrix, echo=-5}
library(tidyverse)
corm <-
  chic %>%
  select(death, temp, dewpoint, pm10, o3) %>%
  corrr::correlate(diagonal = 1) %>%
  corrr::shave(upper = FALSE)
corm
```

Now we put the resulting matrix in **long** format using the `pivot_longer()` function from the `{tidyr}` package:

```{r melt-corr-matrix, echo=-3}
corm <- corm %>%
  pivot_longer(
    cols = -term,
    names_to = "colname",
    values_to = "corr"
  ) %>%
  mutate(rowname = fct_inorder(term),
         colname = fct_inorder(colname))
corm
```

For the plot we will use `geom_tile()` for the heatmap and `geom_text()` for the labels:
 
```{r tile-corr-plot}
ggplot(corm, aes(rowname, fct_rev(colname),
                 fill = corr)) +
  geom_tile() +
  geom_text(aes(label = round(corr, 2))) +
  coord_fixed() +
  labs(x = NULL, y = NULL)
```

I like to have a diverging color palette, centered at zero correlation, with white indicating missing data. Also I like to have no grid lines and padding around the heatmap as well as nicely formatted labels that are colored depending on the underlying fill:

```{r tile-corr-plot-polished}
ggplot(corm, aes(rowname, fct_rev(colname),
                 fill = corr)) +
  geom_tile() +
  geom_text(aes(
    label = format(round(corr, 2), nsmall = 2),
    color = abs(corr) < .75
  )) +
  coord_fixed(expand = FALSE) +
  scale_color_manual(values = c("white", "black"),
                     guide = "none") +
  scale_fill_distiller(
    palette = "PuOr", na.value = "white",
    direction = 1, limits = c(-1, 1)
  ) +
  labs(x = NULL, y = NULL) +
  theme(panel.border = element_rect(color = NA, fill = NA),
        legend.position = c(.85, .8))
```
<br>


##### Create a Contour Plot

Contour plots are nice way to display eatesholds of values. One can use them to bin data, showing the density of observations:

```{r contour-outline}
ggplot(chic, aes(temp, o3)) +
  geom_density_2d() +
  labs(x = "Temperatura (¬∞F)", x = "Oz√¥nio Level")
```

```{r contour-filled}
ggplot(chic, aes(temp, o3)) +
  geom_density_2d_filled(show.legend = FALSE) +
  coord_cartesian(expand = FALSE) +
  labs(x = "Temperatura (¬∞F)", x = "Oz√¥nio Level")
```

But now, we are plotting three-dimensional data. We are going to plot the thresholds in dewpoint (i.e. [the temperature at which airborne water vapor will condense to form liquid dew](https://en.wikipedia.org/wiki/Dew_point)) related to temperature and Oz√¥nio levels:

```{r contour-z}
## interpolate data
library(akima)
fld <- with(chic, interp(x = temp, y = o3, z = dewpoint))
## prepare data in long format
library(reshape2)
df <- melt(fld$z, na.rm = TRUE)
names(df) <- c("x", "y", "Dewpoint")
g <- ggplot(data = df, aes(x = x, y = y, z = Dewpoint))  +
  labs(x = "Temperatura (¬∞F)", y = "Oz√¥nio Level",
       color = "Dewpoint")
g + stat_contour(aes(color = ..level.., fill = Dewpoint))
```

Surprise! As it is defined, the drew point is in most cases equal to the measured temperature.

The lines are indicating different levels of drew points, but this is not a pretty plot and also hard to read due to missing borders. Let's try a tile plot using the viridis color palette to encode the dewpoint of each combination of Oz√¥nio level and temperature:

```{r contour-tile}
g + geom_tile(aes(fill = Dewpoint)) +
    scale_fill_viridis_c(option = "inferno")
```

How does it look if we combine a contour plot and a tile plot to fill the area under the contour lines?

```{r contour-and-tile}
g + geom_tile(aes(fill = Dewpoint)) +
    stat_contour(color = "white", size = .7, bins = 5) +
    scale_fill_viridis_c()
```


##### Create a Heatmap

Similarly to our first contour maps, one can easily show the counts or densities of points binned to a hexagonal grid via `geom_hex()`:

```{r heatmap-hex}
ggplot(chic, aes(temp, o3)) +
  geom_hex() +
  scale_fill_distiller(palette = "YlOrRd", direction = 1) +
  labs(x = "Temperatura (¬∞F)", y = "Oz√¥nio Level")
```

Often, white lines pop up in the resulting plot. One can fix that by mapping also color to either `..count..` (the default) or `..density..`...

```{r heatmap-hex-ouline}
ggplot(chic, aes(temp, o3)) +
  geom_hex(aes(color = ..count..)) +
  scale_fill_distiller(palette = "YlOrRd", direction = 1) +
  scale_color_distiller(palette = "YlOrRd", direction = 1) +
  labs(x = "Temperatura (¬∞F)", y = "Oz√¥nio Level")
```

... or by setting the same color as outline for all hexagonal cells:

```{r heatmap-hex-ouline-grey}
ggplot(chic, aes(temp, o3)) +
  geom_hex(color = "grey") +
  scale_fill_distiller(palette = "YlOrRd", direction = 1) +
  labs(x = "Temperatura (¬∞F)", y = "Oz√¥nio Level")
```

One can also change the default binning to in- or decrease the number of hexagonal cells:

```{r heatmap-hex-bins}
ggplot(chic, aes(temp, o3, fill = ..density..)) +
  geom_hex(bins = 50, color = "grey") +
  scale_fill_distiller(palette = "YlOrRd", direction = 1) +
  labs(x = "Temperatura (¬∞F)", y = "Oz√¥nio Level")
```

If you want to have a regular grid, one can also use `geom_bin2d()` which summarizes the data to rectangular grid cells based on `bins`:

```{r heatmap-rect-bins}
ggplot(chic, aes(temp, o3, fill = ..density..)) +
  geom_bin2d(bins = 15, color = "grey") +
  scale_fill_distiller(palette = "YlOrRd", direction = 1) +
  labs(x = "Temperatura (¬∞F)", y = "Oz√¥nio Level")
```


##### Create a Ridge Plot

*Ridge(line) plots* are a new type of plots which is very popular at the moment.

While you can create those plots with [basic `{ggplot2}` commands](https://github.com/halhen/viz-pub/blob/master/sports-time-of-day/2_gen_chart.R) the popularity lead to a package that make it easier create those plots: [`{ggridges}`](https://cran.r-project.org/web/packages/ggridges/index.html). We are going to use this package here.

```{r ridges}
library(ggridges)
ggplot(chic, aes(x = temp, y = factor(year))) +
   geom_density_ridges(fill = "gray90") +
   labs(x = "Temperatura (¬∞F)", y = "Ano")
```

You can easily specify the overlap and the trailing tails by using the arguments `rel_min_height` and `scale`, respectively. The package also comes with  its own theme (but I would prefer to build my own, see chapter ["Create and Use Your Custom Theme"](#themes)). Additionally, we change the colors based on year to make it more appealing.

```{r ridges-spec}
ggplot(chic, aes(x = temp, y = factor(year), fill = year)) +
  geom_density_ridges(alpha = .8, color = "white",
                      scale = 2.5, rel_min_height = .01) +
  labs(x = "Temperatura (¬∞F)", y = "Ano") +
  guides(fill = FALSE) +
  theme_ridges()
```

You can also get rid of the overlap using values below 1 for the scaling argument (but this somehow contradicts the idea of ridge plots...). Here is an example additionally using the viridis color gradient and the in-build theme:

```{r ridges-viridis}
ggplot(chic, aes(x = temp, y = season, fill = ..x..)) +
  geom_density_ridges_gradient(scale = .9, gradient_lwd = .5,
                               color = "black") +
  scale_fill_viridis_c(option = "plasma", name = "") +
  labs(x = "Temperatura (¬∞F)", y = "Season") +
  theme_ridges(font_family = "Roboto Condensed", grid = FALSE)
```

We can also compare several groups per ridgeline and coloring them according to their group. This follows the idea of [Marc Belzunces](https://twitter.com/marcbeldata/status/888697140268204032).

```{r ridges-groups}
library(tidyverse)
## only plot extreme season using dplyr from the tidyverse
ggplot(data = filter(chic, season %in% c("Summer", "Winter")),
         aes(x = temp, y = year, fill = paste(year, season))) +
  geom_density_ridges(alpha = .7, rel_min_height = .01,
                      color = "white", from = -5, to = 95) +
  scale_fill_cyclical(breaks = c("1997 Summer", "1997 Winter"),
                      labels = c(`1997 Summer` = "Summer",
                                 `1997 Winter` = "Winter"),
                      values = c("tomato", "dodgerblue"),
                      name = "Season:", guide = "legend") +
  theme_ridges(grid = FALSE) +
  labs(x = "Temperatura (¬∞F)", y = "Ano")
```

The `{ggridges}` package is also helpful to create histograms for different groups using `stat = "binline"` in the `geom_density_ridges()` command:

```{r ridges-histo}
ggplot(chic, aes(x = temp, y = factor(year), fill = year)) +
  geom_density_ridges(stat = "binline", bins = 25, scale = .9,
                      draw_baseline = FALSE, show.legend = FALSE) +
  theme_minimal() +
  labs(x = "Temperatura (¬∞F)", y = "Season")
```

[‚Üë Voltar para o √çndice.](#toc)<br><br>



## Trabalhando com Ribbons (AUC, CI, etc.) {#ribbons}

This is not a perfect dataset for demonstrating this, but using ribbon can be useful. In this example we will create a 30-day running average using the filter() function so that our ribbon is not too noisy.

```{r ribbon-default}
chic$o3run <- as.numeric(stats::filter(chic$o3, rep(1/30, 30), sides = 2))
ggplot(chic, aes(x = date, y = o3run)) +
   geom_line(color = "chocolate", lwd = .8) +
   labs(x = "Ano", y = "Oz√¥nio")
```

How does it look if we fill in the area below the curve using the `geom_ribbon()` function?

```{r geom-ribbon-AUC}
ggplot(chic, aes(x = date, y = o3run)) +
   geom_ribbon(aes(ymin = 0, ymax = o3run),
               fill = "orange", alpha = .4) +
   geom_line(color = "chocolate", lwd = .8) +
   labs(x = "Ano", y = "Oz√¥nio")
```

Nice to indicate the [area under the curve (AUC)](https://en.wikipedia.org/wiki/Area_under_the_curve_(pharmacokinetics)) but this is not the conventional way to use `geom_ribbon()`.

üíÅ *And actually a nicer way to achieve the same is `geom_area()`.*

<details>
  <summary>Expand to see example.</summary>
```{r geom-area-AUC}
ggplot(chic, aes(x = date, y = o3run)) +
   geom_area(color = "chocolate", lwd = .8,
             fill = "orange", alpha = .4) +
   labs(x = "Ano", y = "Oz√¥nio")
```
</details>

Instead, we draw a ribbon that gives us one standard deviation above and below our data:

```{r geom-ribbon-range}
chic$mino3 <- chic$o3run - sd(chic$o3run, na.rm = TRUE)
chic$maxo3 <- chic$o3run + sd(chic$o3run, na.rm = TRUE)
ggplot(chic, aes(x = date, y = o3run)) +
   geom_ribbon(aes(ymin = mino3, ymax = maxo3), alpha = .5,
               fill = "darkseagreen3", color = "transparent") +
   geom_line(color = "aquamarine4", lwd = .7) +
   labs(x = "Ano", y = "Oz√¥nio")
```

[‚Üë Voltar para o √çndice.](#toc)<br><br> 



## Trabalhando com Smoothings {#smooths}

It is amazingly easy to add smoothing to your data using `{ggplot2}`.


##### Default: Adding a LOESS or GAM Smoothing

You can simply use `stat_smooth()`‚Äî not even a formula is required. This adds a LOESS (locally weighted scatter plot smoothing, `method = "loess"`) if you have fewer than 1000 points or a GAM (generalized additive model, `method = "gam"`) otherwise. Since we have more than 1000 points, the smoothing is based on a GAM:

```{r stat-smooth, message=TRUE}
ggplot(chic, aes(x = date, y = temp)) +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  stat_smooth() +
  geom_point(color = "gray40", alpha = .5)
```
üí° **In most cases one wants the points to be on top of the ribbon so make sure you always call the smoothing before you add the points.**

##### Adding a Linear Fit

Though the default is a LOESS or GAM smoothing, it is also easy to add a standard linear fit:

```{r LM}
ggplot(chic, aes(x = temp, y = death)) +
   labs(x = "Temperatura (¬∞F)", y = "Deaths") +
   stat_smooth(method = "lm", se = FALSE,
               color = "firebrick", size = 1.3) +
   geom_point(color = "gray40", alpha = .5)
```


##### Specifying the Formula for Smoothing

`{ggplot2}` allows you to specify the model you want it to use. Maybe you want to use a [polynomial regression](https://en.wikipedia.org/wiki/Polynomial_regression)?

```{r GAM-spec1}
ggplot(chic, aes(x = o3, y = temp))+
  labs(x = "Oz√¥nio Level", y = "Temperatura (¬∞F)") +
  geom_smooth(
    method = "lm",
    formula = y ~ x + I(x^2) + I(x^3) + I(x^4) + I(x^5),
    color = "black",
    fill = "firebrick"
  ) +
  geom_point(color = "gray40", alpha = .3)
```

<details>
  <summary>&#128129; <i>Huh, `geom_smooth()`? There is an important difference between `geom` and `stat` layers but here it really doesn't matter which one you use. Expand to compare both.</i></summary>
```{r geom-stat-smooth-a}
ggplot(chic, aes(x = o3, y = temp))+
  labs(x = "Oz√¥nio Level", y = "Temperatura (¬∞F)") +
  geom_smooth(stat = "smooth") + ## the default
  geom_point(color = "gray40", alpha = .3)
```

```{r geom-stat-smooth-b}
ggplot(chic, aes(x = o3, y = temp))+
  labs(x = "Oz√¥nio Level", y = "Temperatura (¬∞F)") +
  stat_smooth(geom = "smooth") + ## the default
  geom_point(color = "gray40", alpha = .3)
```
</details>

Or lets say you want to increase the GAM dimension (add some additional wiggles to the smooth):

```{r GAM-spec2, include=TRUE, cache=TRUE}
cols <- c("darkorange2", "firebrick", "dodgerblue3")
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "gray40", alpha = .3) +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  stat_smooth(aes(col = "1000"),
              method = "gam",
              formula = y ~ s(x, k = 1000),
              se = FALSE, size = 1.3) +
  stat_smooth(aes(col = "100"),
              method = "gam",
              formula = y ~ s(x, k = 100),
              se = FALSE, size = 1) +
  stat_smooth(aes(col = "10"),
              method = "gam",
              formula = y ~ s(x, k = 10),
              se = FALSE, size = .8) +
  scale_color_manual(name = "k", values = cols)
```

[‚Üë Voltar para o √çndice.](#toc)<br><br>


## Trabalhando com Interactive Plots {#interactive}

The following collection lists libraries that can be used in combination with `{ggplot2}` or on their own to create interactive visualizations in R (often making use of existing JavaScript libraries).


##### Combination of {ggplot2} and {shiny}

`{shiny}` is a package from [RStudio](https://rstudio.com/) that makes it incredibly easy to build interactive web applications with R. For an introduction and live examples, visit the [Shiny homepage](http://shiny.rstudio.com/).

To look at the potential use, you can check out the Hello Shiny examples. This is the first one:

```{r shiny, eval=FALSE}
library(shiny)
runExample("01_hello")
```

Of course, one can use ggplots in these apps. This example demonstrates the possibility to add some interactive user experience:

```{r shiny-04, eval=FALSE}
runExample("04_mpg")
```


##### Plot.ly via {plotly} and {ggplot2}

[Plot.ly](https://chart-studio.plotly.com/feed/#/) is a tool for creating online, interactive graphics and web apps. The [`{plotly}` package](https://plot.ly/r/getting-started/) enables you to create those directly from your `{ggplot2}` plots and the workflow is surprisingly easy and [can be done from within R](https://plotly-r.com/). However, some of your theme settings might be changed and need to be modified manually afterwards. Also, and unfortunately, it is not straightforward to create facets or true multi-panel plots that scale nicely.

```{r plotly, echo=-3}
g <- ggplot(chic, aes(date, temp)) +
  geom_line(color = "grey") +
  geom_point(aes(color = season)) +
  scale_color_brewer(palette = "Dark2", guide = "none") +
  labs(x = NULL, y = "Temperatura (¬∞F)") +
  theme_bw()
g
library(plotly)
ggplotly(g)
```

Here, for example, it keeps the overall theme setting but adds the legend again.


##### ggiraph and ggplot2

[`{ggiraph}`](https://davidgohel.github.io/ggiraph/index.html) is an R package that allows you to create dynamic `{ggplot2}` graphs. This allows you to add tooltips, animations and JavaScript actions to the graphics. The package also allows the selection of graphical elements when used in Shiny applications.

```{r ggiraph}
library(ggiraph)
g <- ggplot(chic, aes(date, temp)) +
  geom_line(color = "grey") +
  geom_point_interactive(
    aes(color = season, tooltip = season, data_id = season)
  ) +
  scale_color_brewer(palette = "Dark2", guide = "none") +
  labs(x = NULL, y = "Temperatura (¬∞F)") +
  theme_bw()
girafe(ggobj = g)
```

##### Highcharts via {highcharter}

[Highcharts](https://www.highcharts.com/), a software library for interactive charting, is another visualization library written in pure JavaScript that has been ported to R. The package [`{highcharter}`](https://jkunst.com/highcharter/) makes it possible to use them‚Äîbut be aware that Highcharts is only free in case of non-commercial use.

```{r highcharter}
library(highcharter)
hchart(chic, "scatter", hcaes(x = date, y = temp, group = season))
```


##### Echarts via {echarts4r}

[Apache ECharts](https://echarts.apache.org/en/index.html) is a free, powerful charting and visualization library offering an easy way of building intuitive, interactive, and highly customizable charts. Even though it is written in pure JavaScript, one can use it in R via the [`{echarts4r}` library](https://echarts4r.john-coene.com/) thanks to [John Coene](https://john-coene.com/). Check out the impressive [example gallery](https://echarts4r.john-coene.com/articles/chart_types.html) or these two apps ([App 1](https://johncoene.shinyapps.io/fopi-contest/) and [App 2](https://berlinbikes.correlaid.org/)) making use of the `{echarts4r}` functionality.

```{r echarts4r}
library(echarts4r)
chic %>%
  e_charts(date) %>%
  e_scatter(temp, symbol_size = 7) %>%
  e_visual_map(temp) %>%
  e_y_axis(name = "Temperatura (¬∞F)") %>%
  e_legend(FALSE)
```


##### Chart.js via {charter}

[charter](https://github.com/JohnCoene/charter) is another package developed by John Coene that enables the use of a JavaScript visualization library in R. The package allows you to build interactive plots with the help of the [Charts.js framework](https://www.chartjs.org/).

```{r charter, eval=FALSE}
library(charter)
chic$date_num <- as.numeric(chic$date)
## doesn't work with class date
chart(data = chic, caes(date_num, temp)) %>%
  c_scatter(caes(color = season, group = season)) %>%
  c_colors(RColorBrewer::brewer.pal(4, name = "Dark2"))
```
(The example doesn't work in Rmarkdown.)


[‚Üë Voltar para o √çndice.](#toc)<br><br>


## Remarks, Tipps & Resources {#tipps}

##### Using `ggplot()` in Loops and Functions

The grid-based graphics functions in lattice and ggplot2 create a graph object. When you use these functions interactively at the command line, the result is automatically printed, but in `source()` or inside your own functions you will need an explicit `print()` statement, i.e. `print(g)` in most of our examples. See also the [Q&A page of R](https://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-do-lattice_002ftrellis-graphics-not-work_003f).


##### Additional Resources

* ["ggplot2: Elegant Graphics for Data Analysis"](https://ggplot2-book.org/) by Hadley Wickham, available via open-access!
* ["Fundamentals of Data Visualization"](http://serialmentor.com/dataviz/) by Claus O. Wilke about data visualization in general but using `{ggplot2}`. (You can find the codes on [his GitHub profile](https://github.com/clauswilke/dataviz).)
* ["Cookbook for R"](http://www.cookbook-r.com/Graphs/)
by Winston Chang with recipes to produce R plots
* Gallery of the [Top 50 ggplot2 visualizations](http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html)
* Gallery of [`{ggplot2}` extension packages](https://exts.ggplot2.tidyverse.org/gallery/)
* [How to extend `{ggplot2}`](https://cran.r-project.org/web/packages/ggplot2/vignettes/extending-ggplot2.html) by Hadley Wickham
* The fantastic [R4DS Online Learning Community](https://www.rfordatasci.com/) that offers help and mentoring for all things related to the content of the ["R for Data Science" book](r4ds.had.co.nz/) by Hadley Wickham
* [#TidyTuesday](https://github.com/rfordatascience/tidytuesday), a weekly social data project focusing on ggplots‚Äîcheck also [#TidyTuesday on Twitter](https://twitter.com/hashtag/TidyTuesday?lang=en) and [this collection of contributions by Neil Grantham](https://nsgrantham.com/tidytuesdayrocks/)
* A two-part, 4.5-hours tutorial series by Thomas Linn Pedersen ([Part 1](https://www.youtube.com/watch?v=h29g21z0a68) | [Part 2](https://www.youtube.com/watch?v=0m4yywqNPVY))

[‚Üë Voltar para o √çndice.](#toc)<br><br>


***

<details>
<summary style='font-size:10pt;'>R Session Info</summary>

```{r session-info, echo=FALSE, purl=FALSE}
sessionInfo()
```