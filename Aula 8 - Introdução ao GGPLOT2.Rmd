---
title: "Aula 8 - Introdu√ß√£o ao GGPLOT2"
subtitle: "Material adaptado do curso '[A ggplot2 Tutorial for Beautiful Plotting in R ](https://www.cedricscherer.com/2019/08/05/a-ggplot2-tutorial-for-beautiful-plotting-in-r/)'"
author: "Claudiano Neto"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Introductory Words

[I don't care, just show me the content!](#toc)


## Table of Content {#toc}

* [Prepara√ß√£o](#prep)
* [O conjunto de dados](#data)
* [O Pacote `{ggplot2}`](#ggplot)
* [Um ggplot padr√£o](#default)
* [Trabalhando com Eixos](#axes)
* [Trabalhando com Titulos](#titles)
* [Trabalhando com Legendas](#legends)
* [Trabalhando com Planos de fundo e linhas de grade](#style)
* [Trabalhando com margens](#margins)
* [Trabalhando com Gr√°ficos de v√°rios pain√©is](#panels)
* [Trabalhando com Cores](#colors)
* [Trabalhando com Temas](#themes)
* [Trabalhando com Linhas](#lines)
* [Trabalhando com Texto](#text)
* [Trabalhando com Coordenadas](#coords)
* [Trabalhando com Tipos de Gr√°ficos](#charts)
* [Trabalhando com Ribbons (AUC, CI, etc.)](#ribbons)
* [Trabalhando com Smoothings](#smooths)
* [Trabalhando com Plots Interativos](#interactive)
* [Observa√ß√µes, dicas e recursos](#tipps)



## Prepara√ß√£o {#prep}

* Voc√™ pode encontrar o script Rmarkdown com o c√≥digo executado nesta postagem do blog [aqui] (https://github.com/Z3tt/Z3tt/blob/master/content/post/2019-08-05_ggplot2-tutorial.Rmd).
* Voc√™ tamb√©m pode baixar o script R contendo apenas o c√≥digo [aqui] (https://cedricscherer.netlify.app/codes/ggplot-tutorial-cedric-raw.R).
* Voc√™ precisa instalar os seguintes pacotes para executar o tutorial completo:
    + `{ggplot2}`, parte da cole√ß√£o de pacotes `{tidyverse}`
    + `{tidyverse}` cole√ß√£o de pacotes, a saber
      - `{dplyr}` para disputa de dados
      - `{tibble}` para quadros de dados modernos
      - `{tidyr}` para limpeza de dados
      - `{forcats}` para lidar com fatores
    + `{colorspace}` para manipula√ß√£o de cores
    + `{corrr}` para calcular matrizes de correla√ß√£o
    + `{cowplot}` para compor ggplots
    + `{ggdark}` para temas e cores invertidas
    + `{ggforce}` para gr√°ficos sina e outras coisas legais
    + `{ggrepel}` para uma boa rotulagem de texto
    + `{ggridges}` para plotagens de cume
    + `{ggsci}` para belas paletas de cores
    + `{ggtext}` para renderiza√ß√£o avan√ßada de texto
    + `{ggthemes}` para temas adicionais
    + `{grid}` para a cria√ß√£o de objetos gr√°ficos
    + `{gridExtra}` para fun√ß√µes adicionais para gr√°ficos de "grade"
    + `{patchwork}` para gr√°ficos de m√∫ltiplos pain√©is
    + `{rcartocolor}` para √≥timas paletas de cores
    + `{scico}` para paletas uniformes de percep√ß√£o
    + `{showtext}` para fontes personalizadas
    + `{brilhante}` para aplicativos interativos
    + uma s√©rie de pacotes para visualiza√ß√µes interativas
      + `{charter}`
      + `{echarts4r}`
      + `{ggiraph}`
      + `{highcharter}`
      + `{plotly}`

```{r install-packages, eval=FALSE}
# instalando do CRAN packages
install.packages(c("tidyverse", "colorspace", "corrr",  "cowplot",
                   "ggdark", "ggforce", "ggrepel", "ggridges", "ggsci",
                   "ggtext", "ggthemes", "grid", "gridExtra", "patchwork",
                   "rcartocolor", "scico", "showtext", "shiny",
                   "plotly", "highcharter", "echarts4r"))
# instalando do GitHub (aqueles fora do CRAN)
install.packages(devtools)
devtools::install_github("JohnCoene/charter")
```

(For teaching reasons and if people jump to any plot, I load the package needed beside `{ggplot2}` in the respective section.)



## O conjunto de Dados {#data}

We are using data from the *National Morbidity and Mortality Air Pollution Study* (NMMAPS). To make the plots manageable we are limiting the data to Chicago and 1997‚Äì2000. For more detail on this data set, consult Roger Peng's book [Statistical Methods in Environmental Epidemiology with R](http://www.springer.com/de/book/9780387781662).
You can download the data we are using during this tutorial [here](https://github.com/Z3tt/R-Tutorials/blob/master/ggplot2/chicago-nmmaps.csv) (but you don't have to).

We can import the data into our R session for example with `read_csv()` from the `{readr}` package. To access the data later, we are storing it in a variable called `chic` by using the *assignment arrow* `<-`.

Estamos usando dados do *National Morbidity and Mortality Air Pollution Study* (NMMAPS). Para tornar os gr√°ficos gerenci√°veis, estamos limitando os dados a Chicago e entre 1997‚Äì2000. Para obter mais detalhes sobre este conjunto de dados, consulte o livro de Roger Peng [M√©todos Estat√≠sticos em Epidemiologia Ambiental com R] (http://www.springer.com/de/book/9780387781662).
Voc√™ pode baixar os dados que estamos usando durante este tutorial [aqui](https://github.com/Z3tt/R-Tutorials/blob/master/ggplot2/chicago-nmmaps.csv), *mas voc√™ n√£o precisa*.

Podemos importar os dados para nossa sess√£o R, por exemplo, com `read_csv()` do pacote `{readr}`. Para acessar os dados posteriormente, estamos armazenando-os em uma vari√°vel chamada `chic` usando a *seta de atribui√ß√£o* `<-`.


```{r data-import}
chic <- readr::read_csv("https://raw.githubusercontent.com/Z3tt/R-Tutorials/master/ggplot2/chicago-nmmaps.csv")
```

üí° **O `::` √© chamado de *namespace* e pode ser usado para acessar uma fun√ß√£o sem carregar o pacote. Aqui, voc√™ tamb√©m pode executar primeiro a fun√ß√£o `library(readr)` e, depois, o comando `chic <- read_csv (...)`**

```{r data-inspection}
tibble::glimpse(chic)
head(chic, 10)
```


## O Pacote `{ggplot2}`{#ggplot}

> `ggplot2` √© um sistema para criar gr√°ficos declarativamente, baseado em [The Grammar of Graphics](https://link.springer.com/chapter/10.1007/978-3-642-21551-3_13). Voc√™ fornece os dados, diz ao `ggplot2` como mapear as vari√°veis para a est√©tica, quais os elementos gr√°ficos b√°sicos usar o `ggplot2` cuida dos detalhes.
Um ggplot √© constru√≠do a partir de alguns elementos b√°sicos:

1.	**Data**:
Os dados brutos que voc√™ deseja plotar.
2.	**Geometries** `geom_`:
Os dados brutos que voc√™ deseja plotar.
3.	**Aesthetics** `aes()`:
Est√©tica dos objetos geom√©tricos e estat√≠sticos, como posi√ß√£o, cor, tamanho, forma e transpar√™ncia
4.	**Scales** `scale_`:
Mapas entre os dados e as dimens√µes est√©ticas, como intervalo de dados para plotar valores de largura ou fator para cores.
5.	**Statistical transformations** `stat_`:
Resumos estat√≠sticos dos dados, como quantis, curvas ajustadas e somas.
6.	**Coordinate system** `coord_`:
A transforma√ß√£o usada para mapear coordenadas de dados no plano do ret√¢ngulo de dados.
7.	**Facets** `facet_`:
A organiza√ß√£o dos dados em uma grade de gr√°ficos.
8.	**Visual themes** `theme()`:
Os padr√µes visuais gerais de um gr√°fico, como plano de fundo, grades, eixos, tipo de letra padr√£o, tamanhos e cores.

üí° **O n√∫mero de elementos pode variar dependendo de como voc√™ os agrupa e a quem voc√™ pergunta.**

## Um ggplot padr√£o {#default}

Primeiro, para poder usar a funcionalidade de `{ggplot2}`, temos que carregar o pacote (que tamb√©m podemos carregar por meio da [cole√ß√£o de pacotes tidyverse](https://www.tidyverse.org/)):

```{r library}
#library(ggplot2)
library(tidyverse)
```

A sintaxe de `{ggplot2}` √© diferente do R base. De acordo com os elementos b√°sicos, um ggplot padr√£o precisa de tr√™s coisas que voc√™ deve especificar: os *dados*, *est√©tica* e uma *geometria*. Sempre come√ßamos a definir um objeto de plotagem chamando `ggplot(data = df)` que apenas informa ao `{ggplot2}` que vamos trabalhar com esses dados. Na maioria dos casos, voc√™ pode querer representar graficamente duas vari√°veis - uma no eixo x e outra no eixo y. Essas s√£o *est√©ticas posicionais* e, portanto, adicionamos `aes(x = var1, y = var2)` √† chamada `ggplot()` (sim, `aes()` significa est√©tica). No entanto, tamb√©m existem casos em que √© necess√°rio especificar uma ou at√© tr√™s ou mais vari√°veis.

üí° **Especificamos os dados *fora* de `aes ()` e adicionamos as vari√°veis para as quais o ggplot mapeia a est√©tica *dentro* de `aes ()`.**

Here, we map the variable `date` to the x position and the variable `temp` to the y position. Later, we will also map variables to all kind of other aesthetics such as color, size, and shape.

```{r ggplot}
(g <- ggplot(chic, aes(x = date, y = temp)))
```

Olha s√≥, apenas um painel √© criado ao executar isso. Por que? Isso ocorre porque `{ggplot2}` n√£o sabe *como* queremos plotar esses dados ‚Äî ainda precisamos fornecer uma geometria!

`ggplot2` permite que voc√™ armazene o `ggobject` atual em uma vari√°vel de sua escolha, atribuindo-o a uma vari√°vel, em nosso caso chamada `g`. Voc√™ pode estender este `ggobject` posteriormente adicionando outras camadas, todas de uma vez ou atribuindo-o √† mesma ou a outra vari√°vel.

üí° **Usando par√™nteses ao atribuir um objeto, o objeto ser√° impresso imediatamente (ao inv√©s de escrever `g <- ggplot (...)` e ent√£o `g` n√≥s simplesmente escrevemos` (g <- ggplot (...) ) `).**

Existem muitas, muitas geometrias diferentes (chamadas *geoms* porque cada fun√ß√£o geralmente come√ßa com `geom_`) que podem ser adicionadas a um ggplot por padr√£o (veja [aqui](https://ggplot2.tidyverse.org/reference/) para uma lista completa) e ainda mais fornecidos por pacotes de extens√£o (veja [aqui](https://exts.ggplot2.tidyverse.org/) para uma cole√ß√£o de pacotes de extens√£o). Vamos dizer ao `{ggplot2}` qual estilo queremos usar, por exemplo, adicionando `geom_point()` para criar um gr√°fico de dispers√£o:

```{r ggplot-default}
g + geom_point()
```

Massa! Mas esses dados tamb√©m podem ser visualizados como um gr√°fico linear (n√£o √© o ideal, mas as pessoas fazem coisas assim o tempo todo). Ent√£o, simplesmente adicionamos `geom_line()` e voil√°:

```{r ggplot-default-line}
g + geom_line()
```

N√≥s tamb√©m podemos combinar v√°rias outras camadas geom√©tricas - e √© aqui que a magia e a divers√£o come√ßam!

```{r ggplot-default-line-point}
g + geom_line() + geom_point()
```

Por enquanto, √© isso sobre geometrias. N√£o se preocupe, vamos aprender v√°rios tipos de plots em [um ponto posterior](#charts).


##### Alterar as propriedades das geometrias

Dentro do comando `geom_ *`, voc√™ j√° pode manipular a est√©tica visual, como a cor, forma e tamanho de seus pontos. Vamos transformar todos os pontos em grandes diamantes vermelho-fogo!

```{r ggplot-default-col-size-shape}
g + geom_point(color = "firebrick", shape = "diamond", size = 2)
```

üí°**`{ggplot2}` compreende `color` e` colour`, bem como a vers√£o curta `col`. **

<details>
  <summary>&#128129; <i>You can use preset colors (here is a [full list](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)) or [hex color codes](https://www.techopedia.com/definition/29788/color-hex-code), both in quotes, and even RGB/RGBA colors by using the `rgb()` function. Expand to see example.</i></summary>
  
  <details>
   <summary>&#128129; <i>Voc√™ pode usar cores predefinidas (aqui est√° uma [lista completa] (http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)) ou [c√≥digos de cores hexadecimais] (https://www.techopedia.com/definition/29788/color-hex-code), ambos entre aspas e at√© mesmo cores RGB / RGBA usando a fun√ß√£o `rgb ()`. Expanda para ver o exemplo.</i></summary>

```{r ggplot-default-col-size-hex-rgb, eval=FALSE}
g + geom_point(color = "#b22222", shape = "diamond", size = 2)
g + geom_point(color = rgb(178, 34, 34, maxColorValue = 255), shape = "diamond", size = 2)
```

```{r ggplot-default-col-size-hex-rgb-plot, echo=FALSE, purl=FALSE}
library(patchwork)
a <- g + geom_point(color = "#b22222", shape = "diamond", size = 2)
b <- g + geom_point(color = rgb(178, 34, 34, maxColorValue = 255), shape = "diamond", size = 2)
a + b
```

</details>

Cada geom vem com suas pr√≥prias propriedades (chamadas *argumentos*) e o mesmo argumento pode resultar em uma mudan√ßa diferente dependendo do geom que voc√™ est√° usando.

```{r ggplot-default-line_col-size-shape}
g + geom_point(color = "firebrick", shape = "diamond", size = 2) +
    geom_line(color = "firebrick", linetype = "dotted", size = .3)
```


##### Substitua o tema padr√£o `ggplot2`

E para ilustrar um pouco mais a versatilidade do ggplot, vamos nos livrar da apar√™ncia cinza padr√£o `{ggplot2}` definindo um tema integrado diferente, por exemplo, `theme_bw()` ‚Äî chamando `theme_set()` todos os gr√°ficos seguintes ter√£o o mesmo tema preto e branco. Os pontos vermelhos parecem muito melhores agora!

```{r remove-gray-background}
theme_set(theme_bw())
g + geom_point(color = "firebrick")
```

Voc√™ pode saber mais sobre como usar temas embutidos e como personalizar temas na se√ß√£o ["Trabalhando com Temas"](# temas). A partir do pr√≥ximo cap√≠tulo, tamb√©m usaremos a fun√ß√£o `theme()` para personalizar elementos particulares do tema.

üí° **`theme()` √© um comando essencial para modificar manualmente todos os tipos de elementos do tema (textos, ret√¢ngulos e linhas).**

Para ver quais detalhes de um tema ggplot podem ser modificados, d√™ uma olhada [aqui] (https://ggplot2.tidyverse.org/reference/theme.html) ‚Äî e demore algum tempo, esta √© uma lista looonga.

[‚Üë Volte para o √çndice.](#toc)<br><br>



## Trabalhando com Eixos {#axes}

##### Alterar os t√≠tulos dos eixos

Vamos adicionar alguns r√≥tulos bem escritos aos eixos. Para isso, adicionamos `labs()` fornecendo uma string de caracteres para cada r√≥tulo que queremos alterar (aqui, `x` e` y`):

```{r axis-labs}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)")
```

<details>
  <summary>&#128129; <i>Voc√™ tamb√©m pode adicionar cada t√≠tulo de eixo via `xlab()` e `ylab()`. Expanda para ver um exemplo.</i></summary>
```{r axis-labs-2}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  xlab("Year") +
  ylab("Temperature (¬∞F)")
```
</details>

Usually you can also specify symbols by simply adding the symbol itself (here "¬∞") but the code below also allows to add not only symbols but e.g. superscripts:

```{r axis-labs-expression}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = expression(paste("Temperatura (", degree ~ F, ")"^"(Ei, por que devemos usar unidades m√©tricas?!)")))
```


##### Aumente o espa√ßo entre o eixo e os t√≠tulos do eixo

`theme()` √© um comando essencial para modificar elementos espec√≠ficos do tema (textos e t√≠tulos, caixas, s√≠mbolos, planos de fundo, ...). Vamos us√°-los muito! Por enquanto, vamos modificar elementos de texto. Podemos alterar as propriedades de todos ou de elementos de texto espec√≠ficos (aqui t√≠tulos de eixo) sobrescrevendo o `element_text()` padr√£o na chamada `theme()`:

```{r labs-move-away-vjust}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.title.x = element_text(vjust = 0, size = 15),
        axis.title.y = element_text(vjust = 2, size = 15))
```

`vjust` refere-se ao alinhamento vertical, que geralmente varia entre 0 e 1, mas voc√™ tamb√©m pode especificar valores fora desse intervalo. Observe que, embora movamos o t√≠tulo do eixo no eixo y horizontalmente, precisamos especificar `vjust` (que est√° correto da perspectiva do r√≥tulo). Voc√™ tamb√©m pode alterar a dist√¢ncia especificando a margem de ambos os elementos de texto:

```{r labs-move-away-margin}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.title.x = element_text(margin = margin(t = 10), size = 15),
        axis.title.y = element_text(margin = margin(r = 10), size = 15))
```

Os r√≥tulos `t` e` r` dentro do objeto `margin ()` referem-se a *topo* e *direita*, respectivamente. Voc√™ tamb√©m pode especificar as quatro margens como `margem (t, r, b, l)`. Observe que agora temos que alterar a margem direita para modificar o espa√ßo no eixo y, n√£o a margem inferior.

üí° **Uma boa maneira de lembrar a ordem dos lados da margem √© "*t*-*r*-oub-*l*-*e*".**


##### Alterar a est√©tica dos t√≠tulos dos eixos

Novamente, usamos a fun√ß√£o `theme()` e modificamos o elemento `axis.title` e / ou os elementos subordinados` axis.title.x` e `axis.title.y`. Dentro de `element_text()` podemos, por exemplo, sobrescrever os padr√µes para `size`,` color` e `face`:

```{r labs-color-axes-1}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.title = element_text(size = 15, color = "firebrick",
                                  face = "italic"))
```

O argumento `face` pode ser usado para tornar a fonte negritada - `bold`, ou it√°lico - `italic`, ou at√© mesmo negrito-it√°lico -  `bold.italic`.

```{r labs-color-axes-2}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.title.x = element_text(color = "sienna", size = 15),
        axis.title.y = element_text(color = "orangered", size = 15))
```

<details>
  <summary>&#128129; <i> You could also use a combination of `axis.title` and `axis.title.y`, since `axis.title.x` inherits the values from `axis.title`. Expand to see example.</i></summary>
```{r labs-color-axes-3}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.title = element_text(color = "sienna", size = 15),
        axis.title.y = element_text(color = "orangered", size = 15))
```
</details>

√â poss√≠vel modificar algumas propriedades para ambos os t√≠tulos dos eixos e outras apenas para um ou propriedades para cada um por si:

```{r labs-color-axes-4}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.title = element_text(color = "sienna", size = 15, face = "bold"),
        axis.title.y = element_text(face = "bold.italic"))
```


##### Alterar a est√©tica do texto do eixo

Da mesma forma, voc√™ tamb√©m pode alterar a apar√™ncia do texto do eixo (aqui *os n√∫meros*) usando `axis.text` e / ou os elementos subordinados `axis.text.x` e `axis.text.y`:

```{r labs-color-axes-text}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.text = element_text(color = "dodgerblue", size = 12),
        axis.text.x = element_text(face = "italic"))
```


##### Girar Texto do Eixo

Especificar um `√¢ngulo` permite girar qualquer elemento de texto. Com `hjust` e` vjust` voc√™ pode ajustar a posi√ß√£o do texto depois horizontalmente (0 = esquerda, 1 = direita) e verticalmente (0 = superior, 1 = inferior):

```{r axis-text}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.text.x = element_text(angle = 50, vjust = 1, hjust = 1, size = 12))
```


##### Remover Texto do Eixo e Tiquetaques

Pode haver raramente um motivo para fazer isso, mas √© assim que funciona:

```{r axis-no-labs}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank())
```

Eu introduzi tr√™s elementos de tema - texto, linhas e ret√¢ngulos - mas na verdade h√° mais um: `element_blank()` que remove o elemento (e, portanto, n√£o √© considerado um elemento oficial).

üí° **Se voc√™ quiser se livrar de um elemento de tema, o elemento √© sempre `element_blank()`.**


##### Remover t√≠tulos de eixo

Poder√≠amos usar novamente `theme_blank()` mas √© muito mais simples remover o r√≥tulo na chamada `labs()` (ou `xlab()`):

```{r axis-no-title}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = NULL, y = "")
```

üí° **Observe que `NULL` remove o elemento (semelhante a `element_blank()`), enquanto as aspas vazias `""` manter√£o o espa√ßamento para o t√≠tulo do eixo e simplesmente n√£o imprimir√£o nada.**

##### Limite do intervalo do eixo

√Äs vezes, voc√™ deseja <s>ampliar</s> para dar uma olhada mais de perto em alguns intervalos de seus dados. Voc√™ pode fazer isso sem subdividir seus dados:

```{r axis-limit}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Ano", y = "Temperatura (¬∞F)") +
  ylim(c(0, 50)) # limitando de 0 a 50
```

Alternatively you can use `scale_y_continuous(limits = c(0, 50))` or `coord_cartesian(ylim = c(0, 50))`. The former removes all data points outside the range while the second adjusts the visible area and is similar to `ylim(c(0, 50))`. You may wonder: *So in the end both result in the same.* But not really, there is an important difference‚Äîcompare the two following plots:

```{r axis-limit-comp, echo=FALSE, purl=FALSE}
p1 <- ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  scale_y_continuous(limits = c(0, 50)) +
  ggtitle("scale_y_continuous(limits) or ylim()")
p2 <- ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  coord_cartesian(ylim = c(0, 50)) +
  ggtitle("coord_cartesian(ylim)")
library(patchwork)
p1 + p2
```

You might have spotted that on the left there is some empty buffer around your y limits while on the right points are plotted right up to the border and even beyond. This perfectly illustrates the subsetting (left) versus the zooming (right). To show why this is important let's have a look at a different chart type, a box plot:

```{r axis-limit-comp-box, echo=FALSE, purl=FALSE}
p1 <- ggplot(chic, aes(x = factor(year), y = temp)) +
  geom_boxplot() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  scale_y_continuous(limits = c(0, 50)) +
  ggtitle("scale_y_continuous(limits) or ylim()")
p2 <- ggplot(chic, aes(x = factor(year), y = temp)) +
  geom_boxplot() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  coord_cartesian(ylim = c(0, 50)) +
  ggtitle("coord_cartesian(ylim)")
p1 + p2
```

Um. Because `scale_x|y_continuous()` subsets the data first, we get completely different (and wrong, at least if in the case this was not your aim) estimates for the box plots! I hope you don't have to go back to your old scripts now and check if you *maybe* have manipulated your data while plotting and did report wrong summary stats in your report, paper or thesis...


##### Force Plot to Start at Origin

Related to that, you can force R to plot the graph starting at the origin:

```{r origin}
library(tidyverse)
chic_high <- dplyr::filter(chic, temp > 25, o3 > 20)
ggplot(chic_high, aes(x = temp, y = o3)) +
  geom_point(color = "darkcyan") +
  labs(x = "Temperature higher than 25¬∞F",
       y = "Ozone higher than 20 ppb") +
  expand_limits(x = 0, y = 0)
```

<details>
  <summary>&#128129; <i>Using `coord_cartesian(xlim = c(0, NA), ylim = c(0, NA))` will lead to the same result. Expand to see example.</i></summary>
```{r origin-coord}
library(tidyverse)
chic_high <- dplyr::filter(chic, temp > 25, o3 > 20)
ggplot(chic_high, aes(x = temp, y = o3)) +
  geom_point(color = "darkcyan") +
  labs(x = "Temperature higher than 25¬∞F",
       y = "Ozone higher than 20 ppb") +
  coord_cartesian(xlim = c(0, NA), ylim = c(0, NA))
```
</details>

But we can also force it to *literally* start at the origin!

```{r origin-force}
ggplot(chic_high, aes(x = temp, y = o3)) +
  geom_point(color = "darkcyan") +
  labs(x = "Temperature higher than 25¬∞F",
       y = "Ozone higher than 20 ppb") +
  expand_limits(x = 0, y = 0) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  coord_cartesian(clip = "off")
```

üí° **The argument `clip = "off"` in any coordinate system, always starting with `coord_*`, allows to draw outside of the panel area.**

Here, I call it to make sure that the tick marks at `c(0, 0)` are not cut. See the [Twitter thread by Claus Wilke](https://twitter.com/clauswilke/status/991542952802619392?lang=en) for more details.


##### Axes with Same Scaling

For demonstrating purposes, let's plot temperature against temperature with some random noise. The `coord_equal()` is a coordinate system with a specified ratio representing the number of units on the y-axis equivalent to one unit on the x-axis. The default, `ratio = 1`, ensures that one unit on the x-axis is the same length as one unit on the y-axis:

```{r axes-equal}
ggplot(chic, aes(x = temp, y = temp + rnorm(nrow(chic), sd = 20))) +
  geom_point(color = "sienna") +
  labs(x = "Temperature (¬∞F)", y = "Temperature (¬∞F) + random noise") +
  xlim(c(0, 100)) + ylim(c(0, 150)) +
  coord_fixed()
```

Ratios higher than one make units on the y axis longer than units on the x-axis, and vice versa:

```{r axes-fixed-2, fig.height=3}
ggplot(chic, aes(x = temp, y = temp + rnorm(nrow(chic), sd = 20))) +
  geom_point(color = "sienna") +
  labs(x = "Temperature (¬∞F)", y = "Temperature (¬∞F) + random noise") +
  xlim(c(0, 100)) + ylim(c(0, 150)) +
  coord_fixed(ratio = 1/5)
```


##### Use a Function to Alter Labels

Sometimes it is handy to alter your labels a little, perhaps adding units or percent signs without adding them to your data. You can use a function in this case:

```{r labs-alt}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = NULL) +
  scale_y_continuous(label = function(x) {return(paste(x, "Degrees Fahrenheit"))})
```

[‚Üë Jump back to Table of Content.](#toc)<br><br>



## Trabalhando com Titles {#titles}

##### Add a Title

We can add a title via the `ggtitle()` function:

```{r title}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  ggtitle("Temperatures in Chicago")
```

Alternatively, you can use `labs()`. Here you can add several arguments, e.g. additionally a subtitle, a caption and a tag (as well as axis titles as shown before):

```{r title-labs}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)",
       title = "Temperatures in Chicago",
       subtitle = "Seasonal pattern of daily temperatures from 1997 to 2001",
       caption = "Data: NMMAPS",
       tag = "Fig. 1")
```


##### Make Title Bold & Add a Space at the Baseline

Again, since we want to modify the properties of a theme element, we use the `theme()` function and as for the text elements `axis.title` and `axis.text` modify the font face and the margin. All the following modifications of theme elements work not only for the title but for all other labels such as `plot.subtitle`, `plot.caption`, `plot.caption`, `legend.title`, `legend.text`, and `axis.title` and `axis.text`.

```{r title-bold}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)",
       title = "Temperatures in Chicago") +
  theme(plot.title = element_text(face = "bold",
                                  margin = margin(10, 0, 10, 0),
                                  size = 14))
```

üí° **A nice way to remember the order of the margin arguments is "*t*-*r*-oub-*l*-*e*" that resembles the first letter of the four sides.**


##### Adjust Position of Titles

The general alignment (left, center, right) is controlled by `hjust` (which stands for horizontal adjustment):

```{r title-adjust}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = NULL,
       title = "Temperatures in Chicago",
       caption = "Data: NMMAPS") +
  theme(plot.title = element_text(hjust = 1, size = 16, face = "bold.italic"))
```

Of course, there it is also possible to adjust the vertical alignment, controlled by `vjust`.

Since 2019, the user is able to specify the alignment of the title, subtitle, and caption either based on the panel area (the default) or the plot margin via `plot.title.position` and `plot.caption.position`. The later is actually the better choice designwise in most cases and many people were very happy about that new feature since especially with very long y axis labels the alignment looks awful:

```{r title-position-default}
(g <- ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  scale_y_continuous(label = function(x) {return(paste(x, "Degrees Fahrenheit"))}) +
  labs(x = "Year", y = NULL,
       title = "Temperatures in Chicago between 1997 and 2001 in Degrees Fahrenheit",
       caption = "Data: NMMAPS") +
  theme(plot.title = element_text(size = 14, face = "bold.italic"),
        plot.caption = element_text(hjust = 0)))
```

```{r title-position-plot}
g + theme(plot.title.position = "plot",
          plot.caption.position = "plot")
```


##### Use a Non-Traditional Font in Your Title

You can also use different fonts not only the default one provided by ggplot (and which differs between operating systems). There are several packages that help you to use fonts which are installed on your machine (and you may be using in your office program). Here, I use the [`showtext` package](https://github.com/yixuan/showtext) that makes it easy to use various types of fonts (TrueType, OpenType, Type 1, web fonts, etc.) in R plots. After we have loaded the package, you need to import the font that has to be installed on your device as well. I regularly use [Google fonts](https://fonts.google.com/) that can be imported with the function `font_add_google()` but you can also add other fonts with `font_add()`. (Note that even in case of using Google fonts you must install the font‚Äîand restart Rstudio‚Äîto use the font.)

```{r showtext, message = FALSE}
library(showtext)
font_add_google("Playfair Display", ## name of Google font
                "Playfair")  ## name that will be used in R
font_add_google("Bangers", "Bangers")
```

Now, we can use those font families using‚Äîyeah, you guessed right‚Äî`theme()`:

```{r title-style}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)",
       title = "Temperatures in Chicago",
       subtitle = "Daily temperatures in ¬∞F from 1997 to 2001") +
  theme(plot.title = element_text(family = "Bangers", hjust = .5, size = 25),
        plot.subtitle = element_text(family = "Playfair", hjust = .5, size = 15))
```

You can also set a non-default font for all text elements of your plots, for more details see section ["Trabalhando com Themes"](#themes). I am going to use *Roboto Condensed* as the new font for all following plots.

```{r default-font}
font_add_google("Roboto Condensed", "Roboto Condensed")
theme_set(theme_bw(base_size = 12, base_family = "Roboto Condensed"))
```

<p style='color:gray;'>(Previously, this tutorial used the [{extrafont} package](https://cran.r-project.org/web/packages/extrafont/README.html), which did a great job until last year. All of the sudden I couldn't add any new fonts anymore and after getting a new laptop, the package did not find any fonts at all... I usually suggest the [{ragg} package](https://ragg.r-lib.org/) now. However, I did not succeed to make it work for my homepage so I use the `{showtext}` package which is great as well with the only main difference that you need to import the font you want to use explicitly with `{showtext}`. However, it seems [there are some technical details that are not solved optimally by `{showtext}`](https://twitter.com/thomasp85/status/1355083725156077571) so you may want to use the package as a very last resort.)</p>


##### Change Spacing in Multi-Line Text

You can use the `lineheight` argument to change the spacing between lines. In this example, I have squished the lines together (lineheight < 1).

```{r multiline-title}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  ggtitle("Temperatures in Chicago\nfrom 1997 to 2001") +
  theme(plot.title = element_text(lineheight = .8, size = 16))
```

[‚Üë Jump back to Table of Content.](#toc)<br><br>



## Trabalhando com Legends {#legends}

We will color code the plot based on season. Or to phrase it in a more ggplot'ish way: we map the variable `season` to the `aes`thetic `color`. One nice thing about `{ggplot2}` is that it adds a legend by default when mapping a variable to an aesthetic. You can see that by default the legend title is what we specified in the color argument:

```{r legend-default}
ggplot(chic,
       aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)")
```


##### Turn Off the Legend

Always one of the first question is: "How can I get rid of the legend?".

It is quite easy and always works with `theme(legend.position = "none")`:

```{r legend-none}
ggplot(chic,
       aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(legend.position = "none")
```

You can also use `guides(color = "none")` or `scale_color_discrete(guide = "none")` depending on the specific case. While the change of the theme element removes all legends at once, you can remove particular legends with the latter options while keeping some others:

```{r legend-none-guides}
ggplot(chic,
       aes(x = date, y = temp,
           color = season, shape = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  guides(color = "none")
```

Here, for example, we keep the legend for the shapes while discarding the one for the colors.


##### Remove Legend Titles

As we already learned, use `element_blank()` to draw *nothing*:

```{r legend-title-off}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(legend.title = element_blank())
```

<details>
  <summary>&#128129; <i>You can achieve the same by setting the legend name to `NULL`, either via `scale_color_discrete(name = NULL)` or `labs(color = NULL)`. Expand to see examples.</i></summary>
```{r legend-title-null}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  scale_color_discrete(name = NULL)
```

```{r legend-title-labs-null}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  labs(color = NULL)
```
</details>

##### Change Legend Position

If you want to place the legend not on the right, one uses `legend.position` as argument in `theme`. Possible positions are "top", "right" (which is the default), "bottom", and "left".

```{r legend-top}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(legend.position = "top")
```

You can also place the legend inside the panel by specifying a vector with relative `x` and `y` coordinates ranging from 0 (left or bottom) to 1 (right or top):

```{r legend-inside}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)",
       color = NULL) +
  theme(legend.position = c(.15, .15),
        legend.background = element_rect(fill = "transparent"))
```

Here, I also overwrite the default white legend background with a transparent fill to make sure the legend does not hide any data points.


##### Change Legend Direction

As you have seen, the legend direction is by default vertical but horizontal when you choose either the "top" or "bottom" position. But you can also switch the direction as you like:

```{r legend-orientation}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(legend.position = c(.5, .97),
        legend.background = element_rect(fill = "transparent")) +
  guides(color = guide_legend(direction = "horizontal"))
```


##### Change Style of the Legend Title

You can change the appearance of the legend title by adjusting the theme element `legend.title`:

```{r legend-style}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(legend.title = element_text(family = "Playfair",
                                    color = "chocolate",
                                    size = 14, face = "bold"))
```


##### Change Legend Title

The easiest way to change the title of the legend is the `labs()` layer:

```{r legend-title-labs}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)",
       color = "Seasons\nindicated\nby colors:") +
  theme(legend.title = element_text(family = "Playfair",
                                    color = "chocolate",
                                    size = 14, face = "bold"))
```

The legend details can be changed via `scale_color_discrete(name = "title")` or `guides(color = guide_legend("title"))`:

```{r legend-title, eval=FALSE}
ggplot(chic, aes(x = date, y = temp, color = season))) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(legend.title = element_text(family = "Playfair",
                                    color = "chocolate",
                                    size = 14, face = "bold")) +
  scale_color_discrete(name = "Seasons\nindicated\nby colors:")
```


##### Change Order of Legend Keys

We can achieve this by changing the levels of `season`:

```{r legend-order}
chic$season <-
  factor(chic$season,
         levels = c("Winter", "Spring", "Summer", "Autumn"))
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)")
```


##### Change Legend Labels

We are going to replace the seasons by the months which they are covering by providing a vector of names in the `scale_color_discrete()` call:

```{r legend-labels}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  scale_color_discrete(
    name = "Seasons:", 
    labels = c("Mar‚ÄîMay", "Jun‚ÄîAug", "Sep‚ÄîNov", "Dec‚ÄîFeb")
  ) +
  theme(legend.title = element_text(
    family = "Playfair", color = "chocolate", size = 14, face = 2
  ))
```


##### Change Background Boxes in the Legend

To change the background color (fill) of the legend keys, we adjust the setting for the theme element `legend.key`:

```{r legend-boxes}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(legend.key = element_rect(fill = "darkgoldenrod1"),
        legend.title = element_text(family = "Playfair",
                                    color = "chocolate",
                                    size = 14, face = 2)) +
  scale_color_discrete("Seasons:")
```

If you want to get rid of them entirely use `fill = NA` or `fill = "transparent"`.


##### Change Size of Legend Symbols

Points in the legend can get a little lost with the default size, especially without the boxes. To override the default one uses again the `guides` layer like this:

```{r legend-symbols}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(legend.key = element_rect(fill = NA),
        legend.title = element_text(color = "chocolate",
                                    size = 14, face = 2)) +
  scale_color_discrete("Seasons:") +
  guides(color = guide_legend(override.aes = list(size = 6)))
```


##### Leave a Layer Off the Legend

Let's say you have two different geoms mapped to the same variable. For example, color as an aesthetic for both a point layer and a rug layer of the same data. By default, both the points and the "line" end up in the legend like this:

```{r legend-layer-1}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  geom_rug()
```

You can use `show.legend = FALSE` to turn off a layer in the legend:

```{r legend-layer-2}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  geom_rug(show.legend = FALSE)
```


##### Manually Adding Legend Items

`{ggplot2}` will not add a legend automatically unless you map aesthetics (color, size etc.) to a variable. There are times, though, that I want to have a legend so that it is clear what you are plotting.

Here is the default:

```{r legend-default-2}
ggplot(chic, aes(x = date, y = o3)) +
  geom_line(color = "gray") +
  geom_point(color = "darkorange2") +
  labs(x = "Year", y = "Ozone")
```

We can force a legend by mapping a guide to a *variable*. We are mapping the lines and the points using `aes()` and we are mapping **not** to a variable in our dataset but to a single string (so that we get just one color for each).

```{r legend-force}
ggplot(chic, aes(x = date, y = o3)) +
  geom_line(aes(color = "line")) +
  geom_point(aes(color = "points")) +
  labs(x = "Year", y = "Ozone") +
  scale_color_discrete("Type:")
```

We are getting close but this is not what we want. We want gray and red! To change the color, we use `scale_color_manual()`. Additionally, we override the legend aesthetics using the `guide()` function.

**Voila!** Now, we have a plot with gray lines and red pints as well as a single gray line and a single red point as legend symbols:

```{r legend-manual}
ggplot(chic, aes(x = date, y = o3)) +
  geom_line(aes(color = "line")) +
  geom_point(aes(color = "points")) +
  labs(x = "Year", y = "Ozone") +
  scale_color_manual(name = NULL,
                     guide = "legend",
                     values = c("points" = "darkorange2",
                                "line" = "gray")) +
  guides(color = guide_legend(override.aes = list(linetype = c(1, 0),
                                                  shape = c(NA, 16))))
```


##### Use Other Legend Styles

The default legend for categorical variables such as `season` is a `guide_legend()` as you have seen in several previous examples. If you map a continuous variable to an aesthetic, `{ggplot2}` will by default not use `guide_legend()` but `guide_colorbar()` (or `guide_colourbar()`):

```{r legend-guide-cont-default}
ggplot(chic,
       aes(x = date, y = temp, color = temp)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)", color = "Temperature (¬∞F)")
```

However, by using `guide_legend()` you can force the legend to show discrete colors for a given number of breaks as in case of a categorical variable:

```{r legend-guide-cont-legend}
ggplot(chic,
       aes(x = date, y = temp, color = temp)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)", color = "Temperature (¬∞F)") +
  guides(color = guide_legend())
```

You can also use *binned scales*:

```{r legend-guide-cont-bins}
ggplot(chic,
       aes(x = date, y = temp, color = temp)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)", color = "Temperature (¬∞F)") +
  guides(color = guide_bins())
```

... or binned scales as *discrete colorbars*:

```{r legend-guide-cont-steps}
ggplot(chic,
       aes(x = date, y = temp, color = temp)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)", color = "Temperature (¬∞F)") +
  guides(color = guide_colorsteps())
```

[‚Üë Jump back to Table of Content.](#toc)<br><br>



## Trabalhando com Backgrounds & Grid Lines {#style}

There are ways to change the entire look of your plot with one function (see ["Trabalhando com Themes"](#themes) section below) but if you want to simply change the colors of some elements, you can also do that.


##### Change the Panel Background Color

To change the background color (fill) of the panel area (i.e. the area where the data is plotted), one needs to adjust the theme element `panel.background`:

```{r panel-color}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "#1D8565", size = 2) +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(panel.background = element_rect(
    fill = "#64D2AA", color = "#64D2AA", size = 2)
  )
```

Note that the true color‚Äîthe outline of the panel background‚Äîdid not change even though we specified it. This is because there is a layer on top of the `panel.background`, namely `panel.border`. However, make sure to use a transparent fill here, otherwise your data is hidden behind this layer. In the following example, I illustrate that by using a semitransparent hex color for the `fill` argument in `element_rect`:

```{r panel-color-2}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "#1D8565", size = 2) +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(panel.border = element_rect(
    fill = "#64D2AA99", color = "#64D2AA", size = 2)
  )
```


##### Change Grid Lines

There are two types of grid lines: major grid lines indicating the ticks and minor grid lines between the major ones. You can change all of these by overwriting the defaults for `panel.grid` or for each set of gridlines separately, `panel.grid.major` and `panel.grid.minor`.

```{r grid-lines}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(panel.grid.major = element_line(color = "gray10", size = .5),
        panel.grid.minor = element_line(color = "gray70", size = .25))
```

You can even specify settings for all four different levels:

```{r grid-lines-x-y}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(panel.grid.major = element_line(size = .5, linetype = "dashed"),
        panel.grid.minor = element_line(size = .25, linetype = "dotted"),
        panel.grid.major.x = element_line(color = "red1"),
        panel.grid.major.y = element_line(color = "blue1"),
        panel.grid.minor.x = element_line(color = "red4"),
        panel.grid.minor.y = element_line(color = "blue4"))
```

And, of course, you can remove some or all grid lines if you like:

```{r grid-remove}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(panel.grid.minor = element_blank())
```

```{r grid-blank}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(panel.grid = element_blank())
```


##### Change Spacing of Gridlines

Furthermore, you can also define the breaks between both, major and minor grid lines:

```{r grid-breaks}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  scale_y_continuous(breaks = seq(0, 100, 10),
                     minor_breaks = seq(0, 100, 2.5))
```


##### Change the Plot Background Color

Similarly, to change the background color (fill) of the plot area, one needs to modify the theme element `plot.background`:

```{r background-color}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(plot.background = element_rect(fill = "gray60",
                                       color = "gray30", size = 2))
```

You can achieve a unique background color by either setting the same colors in both `panel.background` and `plot.background` or by setting the background filling of the panel to `"transparent"` or `NA`:

```{r background-color-same}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(panel.background = element_rect(fill = NA),
        plot.background = element_rect(fill = "gray60",
                                       color = "gray30", size = 2))
```

[‚Üë Jump back to Table of Content.](#toc)<br><br>



## Trabalhando com Margins {#margins}

Sometimes it is useful to add a little space to the plot margin. Similar to the previous examples we can use an argument to the `theme()` function. In this case the argument is `plot.margin`. As In the previous example we already illustrated the default margin by changing the background color using `plot.background`.

Now let us add extra space to both the left and right. The argument, `plot.margin`, can handle a variety of different units (cm, inches, etc.) but it requires the use of the function unit from the package `grid` to specify the units. You can either provide the same value for all sides (easiest via `rep(x, 4)`) or particular distances for each. Here I am using a 1cm margin on the top and bottom, 3 cm margin on the right, and a 8 cm margin on the left.

```{r margin}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(plot.background = element_rect(fill = "gray60"),
        plot.margin = margin(t = 1, r = 3, b = 1, l = 8, unit = "cm"))
```

The order of the margin sides is top, right, bottom, left‚Äîa nice way to remember this order is "**tr**ou**bl**e that sorts the first letter of the four sides.

<details>
  <summary>&#128129; <i>You can also use `unit()` instead of `margin()`. Expand to see example.</i></summary>
```{r margin-2}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(plot.background = element_rect(fill = "gray60"),
        plot.margin = unit(c(1, 3, 1, 8), "cm"))
```
</details>



[‚Üë Jump back to Table of Content.](#toc)<br><br>



## Trabalhando com Multi-Panel Plots {#panels}

The `{ggplot2}` package has two nice functions for creating multi-panel plots, called *facets*. They are related but a little different: `facet_wrap` creates essentially a ribbon of plots based on a single variable while `facet_grid` spans a grid of two variables.


##### Create a Grid of Small Multiples Based on Two Variables

In case of two variables, `facet_grid` does the job. Here, the order of the variables determines the number of rows and columns:

```{r grid-plots}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "orangered", alpha = .3) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  facet_grid(year ~ season)
```

To change from row to column arrangement you can change `facet_grid(year ~ season)` to `facet_grid(season ~ year)`.


##### Create Small Multiples Based on One Variable

`facet_wrap` creates a facet of a single variable, written with a tilde in front: `facet_wrap(~ variable)`. The appearance of these subplots is controlled by the arguments `ncol` and `nrow`:

```{r wrap-plots-1-row}
g <- 
  ggplot(chic, aes(x = date, y = temp)) +
    geom_point(color = "chartreuse4", alpha = .3) +
    labs(x = "Year", y = "Temperature (¬∞F)") +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
g + facet_wrap(~ year)
```

Accordingly, you can arrange the plots as you like, instead as a matrix in one row...

```{r wrap-plots-2-rows}
g + facet_wrap(~ year, nrow = 1)
```

... or even as a asymmetric grid of plots:

```{r wrap-plots-2-rows-3-col}
g + facet_wrap(~ year, ncol = 3) + theme(axis.title.x = element_text(hjust = .15))
```


##### Allow Axes to Roam Free

The default for multi-panel plots in `{ggplot2}` is to use equivalent scales in each panel. But sometimes you want to allow a panels own data to determine the scale. This is often not a good idea since it may give your user the wrong impression about the data. But sometimes it is indeed useful and to do this you can set `scales = "free"`:

```{r wrap-plots-scales-free}
g + facet_wrap(~ year, nrow = 2, scales = "free")
```

Note that both, x and y axes differ in their range!


#### Use `facet_wrap` with Two Variables

The function `facet_wrap` can also take two variables:

```{r wrap-plots-two-vars, fig.height=7}
g + facet_wrap(year ~ season, nrow = 4, scales = "free_x")
```

When using `facet_wrap` you are still able to control the grid design: you can rearrange the number of plots per row and column and you can also let all axes roam free. In contrast, `facet_grid` will also take a `free` argument but will only let it roam free per column or row:

```{r grid-plots-two-vars, fig.height=7}
g + facet_grid(year ~ season, scales = "free_x")
```



##### Modify Style of Strip Texts

By using `theme`, you can modify the appearance of the strip text (i.e. the title for each facet) and the strip text boxes:

```{r facet-modify-striptext, fig.height=3.5}
g + facet_wrap(~ year, nrow = 1, scales = "free_x") +
  theme(strip.text = element_text(face = "bold", color = "chartreuse4",
                                  hjust = 0, size = 20),
        strip.background = element_rect(fill = "chartreuse3", linetype = "dotted"))
```

The following [two functions adapted from this answer by Claus Wilke](https://stackoverflow.com/questions/60332202/conditionally-fill-ggtext-text-boxes-in-facet-wrap), the author of the [`{ggtext}` package](https://wilkelab.org/ggtext/), allow to highlight specific labels in combination with `element_textbox()` that is provided by `{ggtext}`.

```{r facet-color-striptext-function}
library(ggtext)
library(rlang)
element_textbox_highlight <- function(..., hi.labels = NULL, hi.fill = NULL,
                                      hi.col = NULL, hi.box.col = NULL, hi.family = NULL) {
  structure(
    c(element_textbox(...),
      list(hi.labels = hi.labels, hi.fill = hi.fill, hi.col = hi.col, hi.box.col = hi.box.col, hi.family = hi.family)
    ),
    class = c("element_textbox_highlight", "element_textbox", "element_text", "element")
  )
}
element_grob.element_textbox_highlight <- function(element, label = "", ...) {
  if (label %in% element$hi.labels) {
    element$fill <- element$hi.fill %||% element$fill
    element$colour <- element$hi.col %||% element$colour
    element$box.colour <- element$hi.box.col %||% element$box.colour
    element$family <- element$hi.family %||% element$family
  }
  NextMethod()
}
```

Now you can use it and specify for example all striptexts:

```{r facet-color-striptext-A, fig.height=8}
g + facet_wrap(year ~ season, nrow = 4, scales = "free_x") +
  theme(
    strip.background = element_blank(),
    strip.text = element_textbox_highlight(
      family = "Playfair", size = 12, face = "bold",
      fill = "white", box.color = "chartreuse4", color = "chartreuse4",
      halign = .5, linetype = 1, r = unit(5, "pt"), width = unit(1, "npc"),
      padding = margin(5, 0, 3, 0), margin = margin(0, 1, 3, 1),
      hi.labels = c("1997", "1998", "1999", "2000"),
      hi.fill = "chartreuse4", hi.box.col = "black", hi.col = "white"
    )
  )
```

```{r r-facet-color-striptext-B, fig.height=3.5}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(aes(color = season == "Summer"), alpha = .3) +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  facet_wrap(~ season, nrow = 1) +
  scale_color_manual(values = c("gray40", "firebrick"), guide = "none") +
  theme(
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
    strip.background = element_blank(),
    strip.text = element_textbox_highlight(
      size = 12, face = "bold",
      fill = "white", box.color = "white", color = "gray40",
      halign = .5, linetype = 1, r = unit(0, "pt"), width = unit(1, "npc"),
      padding = margin(2, 0, 1, 0), margin = margin(0, 1, 3, 1),
      hi.labels = "Summer", hi.family = "Bangers",
      hi.fill = "firebrick", hi.box.col = "firebrick", hi.col = "white"
    )
  )
```


##### Create a Panel of Different Plots

There are several ways how plots can be combined. The easiest approach in my opinion is the [`{patchwork}` package](https://github.com/thomasp85/patchwork) by Thomas Lin Pedersen:

```{r combine-plots-patchwork}
p1 <- ggplot(chic, aes(x = date, y = temp,
                       color = season)) +
        geom_point() +
        geom_rug() +
        labs(x = "Year", y = "Temperature (¬∞F)")
p2 <- ggplot(chic, aes(x = date, y = o3)) +
        geom_line(color = "gray") +
        geom_point(color = "darkorange2") +
        labs(x = "Year", y = "Ozone")
library(patchwork)
p1 + p2
```

We can change the order by "dividing" both plots (and note the alignment even though one has a legend and one doesn't!):

```{r combine-plots-patchwork-2, fig.height=8}
p1 / p2
```

And also nested plots are possible!

```{r combine-plots-patchwork-3, fig.height=6}
(g + p2) / p1
```

(Note the alignment of the plots even though only one plot includes a legend.)

Alternatively, the [`{cowplot}` package](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html) by Claus Wilke provides the functionality to combine multiple plots (and lots of other good utilities):

```{r combine-plots-cowplot}
library(cowplot)
plot_grid(plot_grid(g, p1), p2, ncol = 1)
```

... and so does the [`{gridExtra}` package](https://cran.r-project.org/web/packages/gridExtra/vignettes/arrangeGrob.html) as well:

```{r combine-plots-grid}
library(gridExtra)
grid.arrange(g, p1, p2,
             layout_matrix = rbind(c(1, 2), c(3, 3)))
```

The same idea of defining a layout can be used with `{patchwork}` which allows creating complex compositions:

```{r combine-plots-patchwork-layout, fig.width=12, fig.height=8}
layout <- "
AABBBB#
AACCDDE
##CCDD#
##CC###
"
p2 + p1 + p1 + g + p2 +
  plot_layout(design = layout)
```

[‚Üë Jump back to Table of Content.](#toc)<br><br>



## Trabalhando com Colors {#colors}

For simple applications Trabalhando com colors is straightforward in `{ggplot2}`. For a more advanced treatment of the topic you should probably get your hands on [Hadley's book](http://www.springer.com/de/book/9780387981413#otherversion=9780387981406) which has nice coverage. Other good sources are the [R Cookbook](http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/) and the [`color section in the R Graph Gallery](https://www.r-graph-gallery.com/ggplot2-color.html) by Yan Holtz.

There are two main differences when it comes to colors in `{ggplot2}`. Both arguments, `color` and `fill`, can be

1. specified as single color or
2. assigned to variables.

As you have already seen in the beginning of this tutorial, variables that are *inside* the `aes`thetics are encoded by variables and those that are *outside* are properties that are unrelated to the variables. This complete nonsense plot showing the number of records per year and season illustrates that fact:

```{r inside-outside-aes}
ggplot(chic, aes(year)) +
  geom_bar(aes(fill = season), color = "grey", size = 2) +
  labs(x = "Year", y = "Observations", fill = "Season:")
```


##### Specify Single Colors

Static, single colors are simple to use. We can specify a single color for a geom:

```{r color-static}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "steelblue", size = 2) +
  labs(x = "Year", y = "Temperature (¬∞F)")
```

... and in case it provides both, a `color` (outline color) and a `fill` (filling color):

```{r color-fill-static}
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(shape = 21, size = 2, stroke = 1,
             color = "#3cc08f", fill = "#c08f3c") +
  labs(x = "Year", y = "Temperature (¬∞F)")
```

Tian Zheng at Columbia has created a useful [PDF of R colors](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf). Of course, you can also specify hex color codes (simply as strings as in the example above) as well as RGB or RGBA values (via the `rgb()` function: `rgb(red, green, blue, alpha)`).


##### Assign Colors to Variables

In `{ggplot2}`, colors that are assigned to variables are modified via the `scale_color_*` and the `scale_fill_*` functions. In order to use color with your data, most importantly you need to know if you are dealing with a categorical or continuous variable. The color palette should be chosen depending on type of the variable, with sequential or diverging color palettes being used for continuous variables and qualitative color palettes for categorical variables:

<img src="/img/ggplot-tutorial/map-principles-color-schemes.png" style="height: 100%; width: 100%; object-fit: contain" onclick="window.open('https://handsondataviz.org/images/07-map/map-principles-color-schemes.png', 'blank');"/>
<p><figcaption class="caption">Source: "Hands-On Data Visualization" by Jack Dougherty & Ilya Ilyankou</figcaption></p>


##### Qualitative Variables

Qualitative or categorical variables represent types of data which can be divided into groups (*categories*). The variable can be further specified as nominal, ordinal, and binary (dichotomous). Examples of qualitative/categorical variables are:

<img src="/img/ggplot-tutorial/nominal_ordinal_binary.png" style="height: 100%; width: 100%; object-fit: contain" onclick="window.open('https://github.com/allisonhorst/stats-illustrations/raw/master/other-stats-artwork/nominal_ordinal_binary.png', 'blank');"/>
<p><figcaption class="caption">Artwork by Allison Horst</figcaption></p>

The default categorical color palette looks like this:

```{r color-cat-default}
(ga <- ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)", color = NULL))
```


###### Manually Select Qualitative Colors

You can pick your own set of colors and assign them to a categorical variables via the function `scale_*_manual()` (the `*` can be either `color`, `colour`, or `fill`). The number of specified colors has to match the number of categories:

```{r color-cat-manual}
ga + scale_color_manual(values = c("dodgerblue4",
                                   "darkolivegreen4",
                                   "darkorchid3",
                                   "goldenrod1"))
```


###### Use Built-In Qualitative Color Palettes

The [ColorBrewer palettes](http://colorbrewer2.org/) is a popular online tool for selecting color schemes for maps. The different sets of colors have been designed to produce attractive color schemes of similar appearance ranging from three to twelve. Those palettes are available as built-in functions in the `{ggplot2}` package and can be applied by calling `scale_*_brewer()`:

```{r color-brewer}
ga + scale_color_brewer(palette = "Set1")
```

üí° **You can explore all schemes available via `RColorBrewer::display.brewer.all()`.**


###### Use Qualitative Color Palettes from Extension Packages

There are many extension packages that provide additional color palettes. Their use differs depending on the way the package is designed. For an extensive overview of color palettes available in R, check the [collection provided by Emil Hvitfeldt](https://github.com/EmilHvitfeldt/r-color-palettes/blob/master/README.md#comprehensive-list-of-color-palettes-in-r). One can also use his [`{paletteer}` package](https://github.com/EmilHvitfeldt/paletteer), a comprehensive collection of color palettes in R that uses a consistent syntax.

**Examples:**

The [`{ggthemes}` package](https://jrnold.github.io/ggthemes/) for example lets R users access the Tableau colors. Tableau is a famous visualiztion software with a [well-known color palette](http://www.tableau.com/de-de/about/blog/2016/7/colors-upgrade-tableau-10-56782).

```{r color-tableau}
library(ggthemes)
ga + scale_color_tableau()
```

The [`{ggsci}` package](https://cran.r-project.org/web/packages/ggsci/vignettes/ggsci.html) provides scientific journal and sci-fi themed color palettes. Want to have a plot with colors that look like being published in *Science* or *Nature*? Here you go!

```{r color-science-nature, fig.width=10}
library(ggsci)
g1 <- ga + scale_color_aaas()
g2 <- ga + scale_color_npg()
library(patchwork)
(g1 + g2) * theme(legend.position = "top")
```


##### Quantitative Variables

Quantitative variables represent a measurable quantity and are thus numerical. Quantitative data can be further classified as being either continuous (floating numbers possible) or discrete (integers only):

<img src="/img/ggplot-tutorial/continuous_discrete.png" style="height: 100%; width: 100%; object-fit: contain" onclick="window.open('https://github.com/allisonhorst/stats-illustrations/raw/master/other-stats-artwork/continuous_discrete.png', 'blank');"/>
<p><figcaption class="caption">Artwork by Allison Horst</figcaption></p>

In our example we will change the variable we want to color to ozone, a continuous variable that is strongly related to temperature (higher temperature = higher ozone). The function `scale_*_gradient()` is a sequential gradient while `scale_*_gradient2()` is diverging.

Here is the default `{ggplot2}` sequential color scheme for continuous variables:

```{r colors-seq}
gb <- ggplot(chic, aes(x = date, y = temp, color = temp)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)", color = "Temperature (¬∞F):")
gb + scale_color_continuous()
```

This code produces the same plot:

```{r colors-seq-alt, eval=FALSE}
gb + scale_color_gradient()
```

And here is the diverging default color scheme:

```{r colors-seq-alt-2}
mid <- mean(chic$temp)  ## midpoint
gb + scale_color_gradient2(midpoint = mid)
```


###### Manually Set a Sequential Color Scheme

You can manually set gradually changing color palettes for continuous variables via `scale_*_gradient()`:

```{r scale-color-gradient}
gb + scale_color_gradient(low = "darkkhaki",
                          high = "darkgreen")
```

Temperature data is normally distributed so how about a diverging color scheme (rather than sequential)... For diverging color you can use the `scale_*_gradient2()` function:

```{r scale-color-gradient2}
gb + scale_color_gradient2(midpoint = mid, low = "#dd8a0b",
                           mid = "grey92", high = "#32a676")
```


###### The Beautiful Viridis Color Palette

The [**viridis** color palettes](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) do not only make your plots look pretty and good to perceive but also easier to read by those with colorblindness and print well in gray scale.
You can test how your plots might appear under various form of colorblindness using [`dichromate`](https://cran.r-project.org/web/packages/dichromat/index.html) package.

And they also come now shipped with `{ggplot2}`! The following multi-panel plot illustrates three out of the four viridis palettes:

```{r viridis-continuous, fig.width=12, fig.height=7}
p1 <- gb + scale_color_viridis_c() + ggtitle("'viridis' (default)")
p2 <- gb + scale_color_viridis_c(option = "inferno") + ggtitle("'inferno'")
p3 <- gb + scale_color_viridis_c(option = "plasma") + ggtitle("'plasma'")
p4 <- gb + scale_color_viridis_c(option = "cividis") + ggtitle("'cividis'")
library(patchwork)
(p1 + p2 + p3 + p4) * theme(legend.position = "bottom")
```

It is also possible to use the viridis color palettes for discrete variables:

```{r viridis-discrete}
ga + scale_color_viridis_d(guide = "none")
```


###### Use Quantitative Color Palettes from Extension Packages

The many extension packages provide not only additional categorical color palettes but also sequential, diverging and even cyclical palettes. Again, I point you to the great [collection provided by Emil Hvitfeldt](https://github.com/EmilHvitfeldt/r-color-palettes/blob/master/README.md#comprehensive-list-of-color-palettes-in-r) for an overview.

**Examples:**

The [`{rcartocolors}` packages](https://github.com/Nowosad/rcartocolor) ports the beautiful [CARTOcolors](https://www.google.com/search?client=firefox-b-d&q=carto+oclors) to `{ggplot2}` and contains several of my most-used palettes:

```{r color-carto, fig.width=10}
library(rcartocolor)
g1 <- gb + scale_color_carto_c(palette = "BurgYl")
g2 <- gb + scale_color_carto_c(palette = "Earth")
(g1 + g2) * theme(legend.position = "bottom")
```

The [`{scico}` package](https://github.com/thomasp85/scico) provides access to the [color palettes developed by Fabio Crameri](http://www.fabiocrameri.ch/colourmaps.php). These color palettes are not only beautiful and often unusual but also a good choice since they have been developed to be perceptually uniform and ordered. In addition, they work for people with color vision deficiency and in grayscale:

```{r color-scico, fig.width=10}
library(scico)
g1 <- gb + scale_color_scico(palette = "berlin")
g2 <- gb + scale_color_scico(palette = "hawaii", direction = -1)
(g1 + g2) * theme(legend.position = "bottom")
```


#### Modify Color Palettes Afterwards

Since the latest release of `ggplot2 3.0.0`, one can modify layer aesthetics after they have been mapped to the data. Or as the `{ggplot2}` phrases it: "Use `after_scale()` to flag evaluation of mapping for after data has been scaled."

So why not use the modified colors in the first place? Since `{ggplot2}` can only handle one `color` and one `fill` scale, this is an interesting functionality. Look closer at the following example where we use `invert_color()` from the [`{ggdark}` package](https://github.com/nsgrantham/ggdark):

```{r aftercale}
library(ggdark)
ggplot(chic, aes(date, temp, color = temp)) +
  geom_point(size = 5) +
  geom_point(aes(color = temp,
                 color = after_scale(invert_color(color))),
             size = 2) +
  scale_color_scico(palette = "hawaii", guide = "none") +
  labs(x = "Year", y = "Temperature (¬∞F)")
```

Changing the color scheme afterwards is especially fun with functions from the `{ggdark}` and `{colorspace}` packages, namely `invert_color()`, `lighten()`, `darken()` and `desature()`. You can even combine those functions. Here, we plot a box plot that has both arguments, `color` and `fill`:

```{r aftercale-comb}
library(colorspace)
ggplot(chic, aes(date, temp)) +
  geom_boxplot(aes(color = season,
                   fill = after_scale(desaturate(lighten(color, .6), .6))),
               size = 1) +
  scale_color_brewer(palette = "Dark2", guide = "none") +
  labs(x = "Year", y = "Temperature (¬∞F)")
```

Note that you need to specify the `color` and/or `fill` in the `aes()` of the respective `geom_*()` or `stat_*()` to make `after_scale()` work.

üí° **This seems a bit complicated for now‚Äîone could simply use the `color` and `fill` scales for both. Yes, that is true but think about use cases where you need several `color` and/or `fill` scales. In such a case, it would be senseless to occupy the `fill` scale with a slightly darker version of the palette used for `color`.**

[‚Üë Jump back to Table of Content.](#toc)<br><br>



## Trabalhando com Themes {#themes}

##### Change the Overall Plotting Style

You can change the entire look of the plots by using themes. `{ggplot2}` comes with eight built-in themes:

```{r ggplot2-theme-gallery, echo=FALSE, purl=FALSE, fig.width=11, fig.height=7}
p <- ggplot(chic, aes(x = date, y = temp)) +
       geom_point(color = "gray30", alpha = .3) +
       labs(x = "Year", y = "Temperature (¬∞F)")
p1 <- p + theme_gray() + ggtitle("theme_gray()")
p2 <- p + theme_bw() + ggtitle("theme_bw()")
p3 <- p + theme_classic() + ggtitle("theme_classic()")
p4 <- p + theme_dark() + ggtitle("theme_dark()")
p5 <- p + theme_light() + ggtitle("theme_light()")
p6 <- p + theme_linedraw() + ggtitle("theme_linedraw()")
p7 <- p + theme_minimal() + ggtitle("theme_minimal()")
p8 <- p + theme_void() + ggtitle("theme_void()") + theme(plot.title = element_text(color = "black", margin = margin(b = 11/2)))
font_add_google("Roboto Mono", "Roboto Mono")
(p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8) *
  theme(plot.title = element_text(family = "Roboto Mono", hjust = .5, face = "bold", size = 16),
        plot.margin = margin(rep(15, 5))) +
  plot_layout(ncol = 4)
```


There are several packages that provide additional themes, some even with different default color palettes. As an example, Jeffrey Arnold has put together the library `{ggthemes}` with several custom themes imitating popular designs. For a list you can visit the [`{ggthemes}` package site](https://github.com/jrnold/ggthemes). Without any coding you can just adapt several styles, some of them well known for their style and aesthetics.

Here is an example copying the [plotting style](https://www.google.de/search?q=economist+graphic&tbm=isch) in the [The Economist](http://www.economist.com/) magazine by using `theme_economist()` and `scale_color_economist()`:

```{r Economist}
library(ggthemes)
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  ggtitle("Ups and Downs of Chicago's Daily Temperatures") +
  theme_economist() +
  scale_color_economist(name = NULL)
```

Another example is the plotting style of Tufte, a minimal ink theme based on [Edward Tufte](http://ww
w.aiga.org/medalist-edwardtufte)'s book [The Visual Display of Quantitative Information](https://www.edwardtufte.com/tufte/books_vdqi). This is the book that popularized [Minard's chart depicting Napoleon's march on Russia](https://www.edwardtufte.com/tufte/minard) as one of the **best statistical drawings ever created**. Tufte's plots became famous due to the purism in their style. But see yourself:

```{r Tufte}
library(dplyr)
chic_2000 <- filter(chic, year == 2000)
ggplot(chic_2000, aes(x = temp, y = o3)) +
  geom_point() +
  labs(x = "Temperature (¬∞F)", y = "Ozone") +
  ggtitle("Temperature and Ozone Levels During the Year 2000 in Chicago") +
  theme_tufte()
```

I reduced the number of data points here simply to fit it Tufte's minimalism style. If you like the way of plotting have a look on [this blog entry](http://motioninsocial.com/tufte/) creating several Tufte plots in R.

Another neat packages with modern themes and a preset of non-default fonts is the [`{hrbrthemes}` package by Bob Rudis](https://github.com/hrbrmstr/hrbrthemes) with several light but also dark themes:

```{r hrbrthemes, echo=-5}
library(hrbrthemes)
ggplot(chic, aes(x = temp, y = o3)) +
  geom_point(aes(color = dewpoint), show.legend = FALSE) +
  labs(x = "Temperature (¬∞F)", y = "Ozone") +
  ggtitle("Temperature and Ozone Levels in Chicago")
update_geom_defaults("point", list(colour = "black"))
```


##### Change the Font of All Text Elements

It is incredibly easy to change the settings of all the text elements at once. All themes come with an argument called `base_family`:

```{r theme-base-text-family}
g <- ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "firebrick") +
  labs(x = "Year", y = "Temperature (¬∞F)",
       title = "Temperatures in Chicago")
g + theme_bw(base_family = "Playfair")
```


##### Change the Size of All Text Elements

The `theme_*()` functions also come with several other `base_*` arguments. If you have a closer look at the default theme (see chapter "Create and Use Your Custom Theme" below) you will notice that the sizes of all the elements are relative `(rel())` to the `base_size`. As a result, you can simply change the `base_size` if you want to increase readability of your plots:

```{r theme-base-text-size}
g + theme_bw(base_size = 30, base_family = "Roboto Condensed")
```


##### Change the Size of All Line and Rect Elements

Similarly, you can change the size of all elements of type `line` and `rect`:

```{r theme-base-line-size}
g + theme_bw(base_line_size = 1, base_rect_size = 1)
```


##### Create Your Own Theme

If you want to change the theme for an entire session you can use `theme_set` as in `theme_set(theme_bw())`. The default is called `theme_gray` (or `theme_gray`). If you wanted to create your own custom theme, you could extract the code directly from the gray theme and modify. Note that the `rel()` function change the sizes relative to the `base_size`.

```{r theme-default}
theme_gray
```

Now, let us modify the default theme function and have a look at the result:

```{r theme-mods, results="hide"}
theme_custom <- function (base_size = 12, base_family = "Roboto Condensed") {
  half_line <- base_size/2
  theme(
    line = element_line(color = "black", size = .5,
                        linetype = 1, lineend = "butt"),
    rect = element_rect(fill = "white", color = "black",
                        size = .5, linetype = 1),
    text = element_text(family = base_family, face = "plain",
                        color = "black", size = base_size,
                        lineheight = .9, hjust = .5, vjust = .5,
                        angle = 0, margin = margin(), debug = FALSE),
    axis.line = element_blank(),
    axis.line.x = NULL,
    axis.line.y = NULL,
    axis.text = element_text(size = base_size * 1.1, color = "gray30"),
    axis.text.x = element_text(margin = margin(t = .8 * half_line/2),
                               vjust = 1),
    axis.text.x.top = element_text(margin = margin(b = .8 * half_line/2),
                                   vjust = 0),
    axis.text.y = element_text(margin = margin(r = .8 * half_line/2),
                               hjust = 1),
    axis.text.y.right = element_text(margin = margin(l = .8 * half_line/2),
                                     hjust = 0),
    axis.ticks = element_line(color = "gray30", size = .7),
    axis.ticks.length = unit(half_line / 1.5, "pt"),
    axis.ticks.length.x = NULL,
    axis.ticks.length.x.top = NULL,
    axis.ticks.length.x.bottom = NULL,
    axis.ticks.length.y = NULL,
    axis.ticks.length.y.left = NULL,
    axis.ticks.length.y.right = NULL,
    axis.title.x = element_text(margin = margin(t = half_line),
                                vjust = 1, size = base_size * 1.3,
                                face = "bold"),
    axis.title.x.top = element_text(margin = margin(b = half_line),
                                    vjust = 0),
    axis.title.y = element_text(angle = 90, vjust = 1,
                                margin = margin(r = half_line),
                                size = base_size * 1.3, face = "bold"),
    axis.title.y.right = element_text(angle = -90, vjust = 0,
                                      margin = margin(l = half_line)),
    legend.background = element_rect(color = NA),
    legend.spacing = unit(.4, "cm"),
    legend.spacing.x = NULL,
    legend.spacing.y = NULL,
    legend.margin = margin(.2, .2, .2, .2, "cm"),
    legend.key = element_rect(fill = "gray95", color = "white"),
    legend.key.size = unit(1.2, "lines"),
    legend.key.height = NULL,
    legend.key.width = NULL,
    legend.text = element_text(size = rel(.8)),
    legend.text.align = NULL,
    legend.title = element_text(hjust = 0),
    legend.title.align = NULL,
    legend.position = "right",
    legend.direction = NULL,
    legend.justification = "center",
    legend.box = NULL,
    legend.box.margin = margin(0, 0, 0, 0, "cm"),
    legend.box.background = element_blank(),
    legend.box.spacing = unit(.4, "cm"),
    panel.background = element_rect(fill = "white", color = NA),
    panel.border = element_rect(color = "gray30",
                                fill = NA, size = .7),
    panel.grid.major = element_line(color = "gray90", size = 1),
    panel.grid.minor = element_line(color = "gray90", size = .5,
                                    linetype = "dashed"),
    panel.spacing = unit(base_size, "pt"),
    panel.spacing.x = NULL,
    panel.spacing.y = NULL,
    panel.ontop = FALSE,
    strip.background = element_rect(fill = "white", color = "gray30"),
    strip.text = element_text(color = "black", size = base_size),
    strip.text.x = element_text(margin = margin(t = half_line,
                                                b = half_line)),
    strip.text.y = element_text(angle = -90,
                                margin = margin(l = half_line,
                                                r = half_line)),
    strip.text.y.left = element_text(angle = 90),
    strip.placement = "inside",
    strip.placement.x = NULL,
    strip.placement.y = NULL,
    strip.switch.pad.grid = unit(0.1, "cm"),
    strip.switch.pad.wrap = unit(0.1, "cm"),
    plot.background = element_rect(color = NA),
    plot.title = element_text(size = base_size * 1.8, hjust = .5,
                              vjust = 1, face = "bold",
                              margin = margin(b = half_line * 1.2)),
    plot.title.position = "panel",
    plot.subtitle = element_text(size = base_size * 1.3,
                                 hjust = .5, vjust = 1,
                                 margin = margin(b = half_line * .9)),
    plot.caption = element_text(size = rel(0.9), hjust = 1, vjust = 1,
                                margin = margin(t = half_line * .9)),
    plot.caption.position = "panel",
    plot.tag = element_text(size = rel(1.2), hjust = .5, vjust = .5),
    plot.tag.position = "topleft",
    plot.margin = margin(base_size, base_size, base_size, base_size),
    complete = TRUE
  )
}
```

üí° **You can only overwrite the defaults for all elements you want to change. Here I listed all so you can see that you can change *literally* change everything!**

Have a look on the modified aesthetics with its new look of panel and gridlines as well as axes ticks, texts and titles:

```{r theme-set}
theme_set(theme_custom())
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() + labs(x = "Year", y = "Temperature (¬∞F)") + guides(color = FALSE)
```

**This way of changing the plot design is highly recommended!** It allows you to quickly change any element of your plots by changing it once. You can within a few seconds plot all your results in a congruent style and adapt it to other needs (e.g. a presentation with bigger font size or journal requirements).


##### Update the Current Theme

You can also set quick changes using `theme_update()`:

```{r theme-update}
theme_custom <- theme_update(panel.background = element_rect(fill = "gray60"))
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point() + labs(x = "Year", y = "Temperature (¬∞F)") + guides(color = FALSE)
```

For further exercises, we are going to use our own theme with a white filling and without the minor grid lines:

```{r theme-reset}
theme_custom <- theme_update(panel.background = element_rect(fill = "white"),
                             panel.grid.major = element_line(size = .5),
                             panel.grid.minor = element_blank())
```

[‚Üë Jump back to Table of Content.](#toc)<br><br>



## Trabalhando com Lines {#lines}

##### Add Horizonal or Vertical Lines to a Plot

You might want to highlight a given range or threshold, which can be done plotting a line at defined coordinates using `geom_hline()` (for "horizontal lines") or `geom_vline()` (for "vertical lines"):

```{r hline}
ggplot(chic, aes(x = date, y = temp, color = o3)) +
  geom_point() +
  geom_hline(yintercept = c(0, 73)) +
  labs(x = "Year", y = "Temperature (¬∞F)")
```

```{r vline}
g <- ggplot(chic, aes(x = temp, y = dewpoint)) +
  geom_point(color = "dodgerblue", alpha = .5) +
  labs(x = "Temperature (¬∞F)", y = "Dewpoint")
g +
  geom_vline(aes(xintercept = median(temp)), size = 1.5,
             color = "firebrick", linetype = "dashed") +
  geom_hline(aes(yintercept = median(dewpoint)), size = 1.5,
             color = "firebrick", linetype = "dashed")
```

If you want to add a line with a slope not being 0 or 1, respectively, you need to use `geom_abline()`. This is for example the case if you want to add a regression line using the arguments `intercept` and `slope`:

```{r abline}
reg <- lm(dewpoint ~ temp, data = chic)
g +
  geom_abline(intercept = coefficients(reg)[1],
              slope = coefficients(reg)[2],
              color = "darkorange2", size = 1.5) +
  labs(title = paste0("y = ", round(coefficients(reg)[2], 2),
                      " * x + ", round(coefficients(reg)[1], 2)))
```

Later, we will learn how to add a linear fit with one command using `stat_smooth(method = "lm")`. However, there might be other reasons to add a line with a given slope and this is how one does it ü§∑

##### Add a Line within a Plot

The previous approaches always covered the whole range of the plot panel, but sometimes one wants to highlight only a given area or use lines for annotations. In this case, `geom_linerange()` is here to help:

```{r linerange}
g +
  ## vertical line
  geom_linerange(aes(x = 50, ymin = 20, ymax = 55),
                 color = "steelblue", size = 2) +
  ## horizontal line
  geom_linerange(aes(xmin = -Inf, xmax = 25, y = 0),
                 color = "red", size = 1)
```

Or you can use `geom_segment()` to draw lines with a slope differing from 0 and 1:

```{r segment}
g +
  geom_segment(aes(x = 50, xend = 75,
                   y = 20, yend = 45),
               color = "purple", size = 2)
```


##### Add Curved Lines and Arrows to a Plot

`geom_curve()` adds curves. Well, and straight lines if you like:

```{r curve}
g +
  geom_curve(aes(x = 0, y = 60, xend = 75, yend = 0),
             size = 2, color = "tan") +
  geom_curve(aes(x = 0, y = 60, xend = 75, yend = 0),
             curvature = -0.7, angle = 45,
             color = "darkgoldenrod1", size = 1) +
  geom_curve(aes(x = 0, y = 60, xend = 75, yend = 0),
             curvature = 0, size = 1.5)
```

The same geom can be used to draw arrows:

```{r arrows}
g +
  geom_curve(aes(x = 0, y = 60, xend = 75, yend = 0),
             size = 2, color = "tan",
             arrow = arrow(length = unit(0.07, "npc"))) +
  geom_curve(aes(x = 5, y = 55, xend = 70, yend = 5),
             curvature = -0.7, angle = 45,
             color = "darkgoldenrod1", size = 1,
             arrow = arrow(length = unit(0.03, "npc"),
                           type = "closed",
                           ends = "both"))
```

[‚Üë Jump back to Table of Content.](#toc)<br><br>



## Trabalhando com Text {#text}

##### Add Labels to Your Data

Sometimes, we want to label our data points. To avoid overlaying and crowding by text labels, we use a 1% sample of the original data, equally representing the four seasons. We are using `geom_label()` which comes with a new aesthetic called `label`:

```{r data-text}
set.seed(2020)
library(dplyr)
sample <- chic %>%
  dplyr::group_by(season) %>%
  dplyr::sample_frac(0.01)
## code without pipes:
## sample <- sample_frac(group_by(chic, season), .01)
ggplot(sample, aes(x = date, y = temp, color = season)) +
  geom_point() +
  geom_label(aes(label = season), hjust = .5, vjust = -.5) +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  xlim(as.Date(c('1997-01-01', '2000-12-31'))) +
  ylim(c(0, 90)) +
  theme(legend.position = "none")
```

Okay, avoiding overlap of labels did not work out. But don't worry, we are going to fix it in a minute!

<details>
  <summary>&#128129; <i>You can also use `geom_text()` if you don't like boxes around your labels. Expand to see example.</i></summary>
```{r data-label}
ggplot(sample, aes(x = date, y = temp, color = season)) +
  geom_point() +
  geom_text(aes(label = season), fontface = "bold",
            hjust = .5, vjust = -.25) +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  xlim(as.Date(c('1997-01-01', '2000-12-31'))) +
  ylim(c(0, 90)) +
  theme(legend.position = "none")
```
</details>

A cool thing is the `{ggrepel}` package which provides geoms for `{ggplot2}` to repel overlapping text as in our examples above. We simply replace `geom_text()` by `geom_text_repel()` and `geom_label()` by `geom_label_repel()`:

```{r ggrepel}
library(ggrepel)
ggplot(sample, aes(x = date, y = temp, color = season)) +
  geom_point() +
  geom_label_repel(aes(label = season), fontface = "bold") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(legend.position = "none")
```

It may look nicer with filled boxes so we map `season` to `fill` instead to `color` and set a white color for the text:

```{r ggrepel-filled}
ggplot(sample, aes(x = date, y = temp)) +
  geom_point(data = chic, size = .5) +
  geom_point(aes(color = season), size = 1.5) +
  geom_label_repel(aes(label = season, fill = season),
                   color = "white", fontface = "bold",
                   segment.color = "grey30") +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  theme(legend.position = "none")
```

This also works for the pure text labels by using `geom_text_repel()`. Have a look at all the [usage examples](https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html).

##### Add Text Annotations

There are several ways how one can add annotations to a ggplot. We can again use `geom_text()` or `geom_label()`:

```{r textbox-label}
g <-
  ggplot(chic, aes(x = temp, y = dewpoint)) +
  geom_point(alpha = .5) +
  labs(x = "Temperature (¬∞F)", y = "Dewpoint")
g +
  geom_text(aes(x = 25, y = 60,
                label = "This is a useful annotation"))
```

However, now ggplot has drawn one text label per data point‚Äîthat's 1,461 labels and you only see one! You can solve that by setting the `stat` argument to `"unique"`:

```{r textbox-label-unique}
g +
  geom_text(aes(x = 25, y = 60,
                label = "This is a useful annotation"),
            stat = "unique")
```

By the way, of course one can change the properties of the displayed text:

```{r textbox-label-custom}
g +
  geom_text(aes(x = 25, y = 60,
                label = "This is a useful annotation"),
            stat = "unique", family = "Bangers",
            size = 7, color = "darkcyan")
```

In case you use one of the facet functions to visualize your data you might run into trouble. One thing is that you may want to include the annotation only once:

```{r label-facet-single}
ann <- data.frame(
  o3 = 30,
  temp = 20,
  season = factor("Summer", levels = levels(chic$season)),
  label = "Here is enough space\nfor some annotations."
)
g <-
  ggplot(chic, aes(x = o3, y = temp)) +
  geom_point() +
  labs(x = "Ozone", y = "Temperature (¬∞F)")
g +
  geom_text(data = ann, aes(label = label),
            size = 7, fontface = "bold",
            family = "Roboto Condensed") +
  facet_wrap(~season)
```

Another challenge are facets in combination with free scales that might cut your text:

```{r label-facet-scales-problem}
g +
  geom_text(aes(x = 23, y = 97,
                label = "This is not a useful annotation"),
            size = 5, fontface = "bold") +
  scale_y_continuous(limits = c(NA, 100)) +
  facet_wrap(~season, scales = "free_x")
```

One solution is to calculate the midpoint of the axis, here `x`, beforehand:

```{r label-facet-scales-problem-solved-prep}
library(tidyverse)
(ann <-
  chic %>%
  group_by(season) %>%
  summarize(o3 = min(o3, na.rm = TRUE) +
              (max(o3, na.rm = TRUE) - min(o3, na.rm = TRUE)) / 2))
ann
```

... and use the aggreated data to specify the placement of the annotation:

```{r label-facet-scales-problem-solved-plot}
g +
  geom_text(data = ann,
            aes(x = o3, y = 97,
                label = "This is a useful annotation"),
            size = 5, fontface = "bold") +
  scale_y_continuous(limits = c(NA, 100)) +
  facet_wrap(~season, scales = "free_x")
```

However, there is a simpler approach (in terms of fixing the cordinates)‚Äîbut it also takes a while to know the code by heart. The `{grid}` package in combination with `{ggplot2}`'s `annotation_custom()` allows you to specify the location based on scaled coordinates where 0 is low and 1 is high. `grobTree()` creates a grid graphical object and `textGrob` creates the text graphical object. The value of this is particularly evident when you have multiple plots with different scales.

```{r grobTree}
library(grid)
my_grob <- grobTree(textGrob("This text stays in place!",
                             x = .1, y = .9, hjust = 0,
                             gp = gpar(col = "black",
                                       fontsize = 15,
                                       fontface = "bold")))
g +
  annotation_custom(my_grob) +
  facet_wrap(~season, scales = "free_x") +
  scale_y_continuous(limits = c(NA, 100))
```


##### Use Markdown and HTML Rendering for Annotations

Again, we are using Claus Wilke's [`{ggtext}` package](https://wilkelab.org/ggtext/) that is designed for improved text rendering support for `{ggplot2}`. The `{ggtext}` package defines two new theme elements, `element_markdown()` and `element_textbox()`. The package also provides additional geoms. `geom_richtext()` is a replacement for `geom_text()` and `geom_label()` and renders text as markdown...

```{r ggtext-geom-richtext-md}
library(ggtext)
lab_md <- "This plot shows **temperature** in *¬∞F* versus **ozone level** in *ppm*"
g +
  geom_richtext(aes(x = 35, y = 3, label = lab_md),
                stat = "unique")
```

... or html:

```{r ggtext-geom-richtext-html}
lab_html <- "&#9733; This plot shows <b style='color:red;'>temperature</b> in <i>¬∞F</i> versus <b style='color:blue;'>ozone level</b>in <i>ppm</i> &#9733;"
g +
  geom_richtext(aes(x = 33, y = 3, label = lab_html),
                stat = "unique")
```

The geom comes with a lot of details one can modify, such as angle (which is not possible in the default `geom_text()` and `geom_label()`), properties of the box and properties of the text.

```{r ggtext-geom-richtext-modify}
g +
  geom_richtext(aes(x = 10, y = 25, label = lab_md),
                stat = "unique", angle = 30,
                color = "white", fill = "steelblue",
                label.color = NA, hjust = 0, vjust = 0,
                family = "Playfair Display")
```

The other geom from the `{ggtext}` package is `geom_textbox()`. This geom allows for dynamic wrapping of strings which is very useful for longer annotations such as info boxes and subtitles.

```{r ggtetxt-geom-textbox}
lab_long <- "**Lorem ipsum dolor**<br><i style='font-size:8pt;color:red;'>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.<br>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</i>"
g +
  geom_textbox(aes(x = 40, y = 10, label = lab_long),
               width = unit(15, "lines"), stat = "unique")
```

Note that it is not possible to either rotate the textbox (always horizontal) nor to change the justification of the text (always left-aligned).

[‚Üë Jump back to Table of Content.](#toc)<br><br>



## Trabalhando com Coordinates {#coords}

##### Flip a Plot

It is incredibly easy to flip a plot on its side. Here I have added the `coord_flip()` which is all you need to flip the plot. This makes most sense when using geom's to represent categorical data, for example bar charts or, as in the following example, box and whiskers plots:

```{r flip-coords}
ggplot(chic, aes(x = season, y = o3)) +
  geom_boxplot(fill = "indianred") +
  labs(x = "Season", y = "Ozone") +
  coord_flip()
```

<details>
  <summary>&#128129; <i>Since `{ggplot2}` version 3.0.0 it is also possible to draw geom's horizontally via the argument `orientation = "y"`. Expand to see example.</i></summary>
```{r flip-coords-orientation}
ggplot(chic, aes(x = o3, y = season)) +
  geom_boxplot(fill = "indianred", orientation = "y") +
  labs(x = "Ozone", y = "Season")
```
</details>


##### Fix an Axis

One can fix the aspect ratio of the Cartesian coordinate system and literally force a physical representation of the units along the x and y axes:

```{r fixed-axis-equal, fig.height=5}
ggplot(chic, aes(x = temp, y = o3)) +
  geom_point() +
  labs(x = "Temperature (¬∞F)", y = "Ozone Level") +
  scale_x_continuous(breaks = seq(0, 80, by = 20)) +
  coord_fixed(ratio = 1)
```

This way one can ensure not only a fixed step length on the axes but also that the exported plot looks as expected. However, your saved plot likely contains a lot of white space in case you do not use a suitable aspect ratio:


```{r fixed-axis-scaled, fig.height=4.5, fig.width=9}
ggplot(chic, aes(x = temp, y = o3)) +
  geom_point() +
  labs(x = "Temperature (¬∞F)", y = "Ozone Level") +
  scale_x_continuous(breaks = seq(0, 80, by = 20)) +
  coord_fixed(ratio = 1/3) +
  theme(plot.background = element_rect(fill = "grey80"))
```


##### Reverse an Axis

You can also easily reverse an axis using `scale_x_reverse()` or `scale_y_reverse()`, respectively:

```{r reversed-axis}
ggplot(chic, aes(x = date, y = temp, color = o3)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  scale_y_reverse()
```

<details>
  <summary>&#128129; <i>Note that this will only work for continuous data. If you want to reverse discrete data, use the `fct_rev()` function from the [{forcats} package](https://forcats.tidyverse.org/). Expand to see example.</i></summary>

```{r disc-axes}
## the default
ggplot(chic, aes(x = temp, y = season)) +
  geom_jitter(aes(color = season),
              orientation = "y", show.legend = FALSE) +
  labs(x = "Temperature (¬∞F)", y = NULL)
```

```{r rev-disc-axes}
library(forcats)
ggplot(chic, aes(x = temp, y = fct_rev(season))) +
  geom_jitter(aes(color = season),
              orientation = "y", show.legend = FALSE) +
  labs(x = "Temperature (¬∞F)", y = NULL)
```
</details>


##### Transform an Axis

... or transform the default linear mapping by using `scale_y_log10()` or `scale_y_sqrt()`. As an example, here is a log<sub>10</sub>-transformed axis (which introduces NA's in this case so be careful):

```{r log-axis}
ggplot(chic, aes(x = date, y = temp, color = o3)) +
  geom_point() +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  scale_y_log10(lim = c(0.1, 100))
```


##### Circularize a Plot

It is also possible to circularize (polarize?) the coordinate system by calling `coord_polar()`.

```{r polar-coords}
library(tidyverse)
chic %>%
  dplyr::group_by(season) %>%
  dplyr::summarize(o3 = median(o3)) %>%
  ggplot(aes(x = season, y = o3)) +
    geom_col(aes(fill = season), color = NA) +
    labs(x = "", y = "Median Ozone Level") +
    coord_polar() +
    guides(fill = FALSE)
```

This coordinate system allows to draw pie charts as well:

```{r pie-chart}
chic_sum <-
  chic %>%
  dplyr::mutate(o3_avg = median(o3)) %>%
  dplyr::filter(o3 > o3_avg) %>%
  dplyr::mutate(n_all = n()) %>%
  dplyr::group_by(season) %>%
  dplyr::summarize(rel = n() / unique(n_all))
ggplot(chic_sum, aes(x = "", y = rel)) +
  geom_col(aes(fill = season), width = 1, color = NA) +
  labs(x = "", y = "Proportion of Days Exceeding\nthe Median Ozone Level") +
  coord_polar(theta = "y") +
  scale_fill_brewer(palette = "Set1", name = "Season:") +
  theme(axis.ticks = element_blank(),
        panel.grid = element_blank())
```

I suggest to always look also at the outcome of the same code in a Cartesian coordinate system, which is the default, to understand the logic behind `coord_polar()` and `theta`:

```{r pie-chart-cartesian}
ggplot(chic_sum, aes(x = "", y = rel)) +
  geom_col(aes(fill = season), width = 1, color = NA) +
  labs(x = "", y = "Proportion of Days Exceeding\nthe Median Ozone Level") +
  #coord_polar(theta = "y") +
  scale_fill_brewer(palette = "Set1", name = "Season:") +
  theme(axis.ticks = element_blank(),
        panel.grid = element_blank())
```

[‚Üë Jump back to Table of Content.](#toc)<br><br>



## Trabalhando com Chart Types {#charts}

##### Alternatives to a Box Plot

Box plots are great, but they can be so incredibly boring. Also, even if you are used to looking at box plots, remember there might be plenty people looking at your plot that have never seen a box and whisker plot before.

<details>
<summary>&#128129; <i>Expand for a short recap on box and whiskers plots.</i></summary>

A box-and-whisker plot (sometimes called simply a box plot) is a histogram-like method of displaying data, invented by J. Tukey.  The thick **middle line** notates the median, also known as quartile <i>Q<sub>2</sub></i>. The limits of the **box** are determined by the lower and upper quartiles, <i>Q<sub>1</sub></i> and <i>Q<sub>3</sub></i>. The box contains thus 50% of the data and is called *"interquartile range"* (IQR). The length of the **whiskers** is determined by the most extreme values that are not considered as outliers (i.e. values that are within 3/2 times the interquartile range).<br>
![](/img/evol-ggplot/boxplot.png)
<br>
</details>

There are alternatives, but first we are plotting a common box plot:

```{r boxplot}
g <-
  ggplot(chic, aes(x = season, y = o3,
                   color = season)) +
    labs(x = "Season", y = "Ozone") +
    scale_color_brewer(palette = "Dark2", guide = "none")
g + geom_boxplot()
```


###### 1. Alternative: Plot of Points

Let's plot just each data point of the raw data:

```{r point}
g + geom_point()
```

Not only boring but uninformative. To improve the plot, one could add transparency to deal with overplotting:

```{r point-alpha}
g + geom_point(alpha = .1)
```

However, setting transparency is difficult here since either the overlap is still too high or the extreme values are not visible. Bad, so let's try something else.

###### 2. Alternative: Jitter the Points

Try adding a little jitter to the data. I like this for in-house visualization but be careful using jittering because you are purposely adding noise to your data and this can result in misinterpretation of your data.

```{r jitter}
g + geom_jitter(width = .3, alpha = .5)
```

###### 3. Alternative: Violin Plots

Violin plots, similar to box plots except you are using a kernel density to show where you have the most data, are a useful visualization.

```{r violin}
g + geom_violin(fill = "gray80", size = 1, alpha = .5)
```

###### 4. Alternative: Combining Violin Plots with Jitter

We can of course combine both, estimated densities and the raw data points:

```{r violin-jitter, fig.height=6}
g + geom_violin(fill = "gray80", size = 1, alpha = .5) +
    geom_jitter(alpha = .25, width = .3) +
    coord_flip()
```

The [`{ggforce}` package](https://ggforce.data-imaginist.com/) provides so-called sina functions where the width of the jitter is controlled by the density distribution of the data‚Äîthat makes the jittering a bit more visually appealing:

```{r violin-sina}
library(ggforce)
g + geom_violin(fill = "gray80", size = 1, alpha = .5) +
    geom_sina(alpha = .25) +
    coord_flip()
```

###### 5. Alternative: Combining Violin Plots with Box Plots

To allow for easy estimation of quantiles, we can also add the box of the box plot inside the violins to indicate 25%-quartile, median and 75%-quartile:

```{r violin-jitter-box, fig.height=6}
g + geom_violin(aes(fill = season), size = 1, alpha = .5) +
    geom_boxplot(outlier.alpha = 0, coef = 0,
                 color = "gray40", width = .2) +
    scale_fill_brewer(palette = "Dark2", guide = "none") +
    coord_flip()
```


##### Create a Rug Representation to a Plot

A rug represents the data of a single quantitative variable, displayed as marks along an axis. In most cases, it is used in addition to scatter plots or heatmaps to visualize the overall distribution of one or both of the variables:

```{r rug}
ggplot(chic, aes(x = date, y = temp,
                 color = season)) +
  geom_point(show.legend = FALSE) +
  geom_rug(show.legend = FALSE) +
  labs(x = "Year", y = "Temperature (¬∞F)")
```

```{r rug-2}
ggplot(chic, aes(x = date, y = temp, color = season)) +
  geom_point(show.legend = FALSE) +
  geom_rug(sides = "r", alpha = .3, show.legend = FALSE) +
  labs(x = "Year", y = "Temperature (¬∞F)")
```


##### Create a Correlation Matrix

There are several packages that allow to create correlation matrix plots, some also using the`{ggplot2}` infrastructure and thus returning ggplots. I am going to show you how to do this without extension packages.

First step is to create the correlation matrix. Here, we use the `{corrr}` package that works nicely with pipes but there are also many others out there. We are using Pearson because all the variables are fairly normally distributed (but you may consider Spearman if your variables follow a different pattern). Note that since a correlation matrix has redundant information we are setting half of it to `NA`.

```{r corr-matrix, echo=-5}
library(tidyverse)
corm <-
  chic %>%
  select(death, temp, dewpoint, pm10, o3) %>%
  corrr::correlate(diagonal = 1) %>%
  corrr::shave(upper = FALSE)
corm
```

Now we put the resulting matrix in **long** format using the `pivot_longer()` function from the `{tidyr}` package:

```{r melt-corr-matrix, echo=-3}
corm <- corm %>%
  pivot_longer(
    cols = -term,
    names_to = "colname",
    values_to = "corr"
  ) %>%
  mutate(rowname = fct_inorder(term),
         colname = fct_inorder(colname))
corm
```

For the plot we will use `geom_tile()` for the heatmap and `geom_text()` for the labels:
 
```{r tile-corr-plot}
ggplot(corm, aes(rowname, fct_rev(colname),
                 fill = corr)) +
  geom_tile() +
  geom_text(aes(label = round(corr, 2))) +
  coord_fixed() +
  labs(x = NULL, y = NULL)
```

I like to have a diverging color palette, centered at zero correlation, with white indicating missing data. Also I like to have no grid lines and padding around the heatmap as well as nicely formatted labels that are colored depending on the underlying fill:

```{r tile-corr-plot-polished}
ggplot(corm, aes(rowname, fct_rev(colname),
                 fill = corr)) +
  geom_tile() +
  geom_text(aes(
    label = format(round(corr, 2), nsmall = 2),
    color = abs(corr) < .75
  )) +
  coord_fixed(expand = FALSE) +
  scale_color_manual(values = c("white", "black"),
                     guide = "none") +
  scale_fill_distiller(
    palette = "PuOr", na.value = "white",
    direction = 1, limits = c(-1, 1)
  ) +
  labs(x = NULL, y = NULL) +
  theme(panel.border = element_rect(color = NA, fill = NA),
        legend.position = c(.85, .8))
```
<br>


##### Create a Contour Plot

Contour plots are nice way to display eatesholds of values. One can use them to bin data, showing the density of observations:

```{r contour-outline}
ggplot(chic, aes(temp, o3)) +
  geom_density_2d() +
  labs(x = "Temperature (¬∞F)", x = "Ozone Level")
```

```{r contour-filled}
ggplot(chic, aes(temp, o3)) +
  geom_density_2d_filled(show.legend = FALSE) +
  coord_cartesian(expand = FALSE) +
  labs(x = "Temperature (¬∞F)", x = "Ozone Level")
```

But now, we are plotting three-dimensional data. We are going to plot the thresholds in dewpoint (i.e. [the temperature at which airborne water vapor will condense to form liquid dew](https://en.wikipedia.org/wiki/Dew_point)) related to temperature and ozone levels:

```{r contour-z}
## interpolate data
library(akima)
fld <- with(chic, interp(x = temp, y = o3, z = dewpoint))
## prepare data in long format
library(reshape2)
df <- melt(fld$z, na.rm = TRUE)
names(df) <- c("x", "y", "Dewpoint")
g <- ggplot(data = df, aes(x = x, y = y, z = Dewpoint))  +
  labs(x = "Temperature (¬∞F)", y = "Ozone Level",
       color = "Dewpoint")
g + stat_contour(aes(color = ..level.., fill = Dewpoint))
```

Surprise! As it is defined, the drew point is in most cases equal to the measured temperature.

The lines are indicating different levels of drew points, but this is not a pretty plot and also hard to read due to missing borders. Let's try a tile plot using the viridis color palette to encode the dewpoint of each combination of ozone level and temperature:

```{r contour-tile}
g + geom_tile(aes(fill = Dewpoint)) +
    scale_fill_viridis_c(option = "inferno")
```

How does it look if we combine a contour plot and a tile plot to fill the area under the contour lines?

```{r contour-and-tile}
g + geom_tile(aes(fill = Dewpoint)) +
    stat_contour(color = "white", size = .7, bins = 5) +
    scale_fill_viridis_c()
```


##### Create a Heatmap

Similarly to our first contour maps, one can easily show the counts or densities of points binned to a hexagonal grid via `geom_hex()`:

```{r heatmap-hex}
ggplot(chic, aes(temp, o3)) +
  geom_hex() +
  scale_fill_distiller(palette = "YlOrRd", direction = 1) +
  labs(x = "Temperature (¬∞F)", y = "Ozone Level")
```

Often, white lines pop up in the resulting plot. One can fix that by mapping also color to either `..count..` (the default) or `..density..`...

```{r heatmap-hex-ouline}
ggplot(chic, aes(temp, o3)) +
  geom_hex(aes(color = ..count..)) +
  scale_fill_distiller(palette = "YlOrRd", direction = 1) +
  scale_color_distiller(palette = "YlOrRd", direction = 1) +
  labs(x = "Temperature (¬∞F)", y = "Ozone Level")
```

... or by setting the same color as outline for all hexagonal cells:

```{r heatmap-hex-ouline-grey}
ggplot(chic, aes(temp, o3)) +
  geom_hex(color = "grey") +
  scale_fill_distiller(palette = "YlOrRd", direction = 1) +
  labs(x = "Temperature (¬∞F)", y = "Ozone Level")
```

One can also change the default binning to in- or decrease the number of hexagonal cells:

```{r heatmap-hex-bins}
ggplot(chic, aes(temp, o3, fill = ..density..)) +
  geom_hex(bins = 50, color = "grey") +
  scale_fill_distiller(palette = "YlOrRd", direction = 1) +
  labs(x = "Temperature (¬∞F)", y = "Ozone Level")
```

If you want to have a regular grid, one can also use `geom_bin2d()` which summarizes the data to rectangular grid cells based on `bins`:

```{r heatmap-rect-bins}
ggplot(chic, aes(temp, o3, fill = ..density..)) +
  geom_bin2d(bins = 15, color = "grey") +
  scale_fill_distiller(palette = "YlOrRd", direction = 1) +
  labs(x = "Temperature (¬∞F)", y = "Ozone Level")
```


##### Create a Ridge Plot

*Ridge(line) plots* are a new type of plots which is very popular at the moment.

While you can create those plots with [basic `{ggplot2}` commands](https://github.com/halhen/viz-pub/blob/master/sports-time-of-day/2_gen_chart.R) the popularity lead to a package that make it easier create those plots: [`{ggridges}`](https://cran.r-project.org/web/packages/ggridges/index.html). We are going to use this package here.

```{r ridges}
library(ggridges)
ggplot(chic, aes(x = temp, y = factor(year))) +
   geom_density_ridges(fill = "gray90") +
   labs(x = "Temperature (¬∞F)", y = "Year")
```

You can easily specify the overlap and the trailing tails by using the arguments `rel_min_height` and `scale`, respectively. The package also comes with  its own theme (but I would prefer to build my own, see chapter ["Create and Use Your Custom Theme"](#themes)). Additionally, we change the colors based on year to make it more appealing.

```{r ridges-spec}
ggplot(chic, aes(x = temp, y = factor(year), fill = year)) +
  geom_density_ridges(alpha = .8, color = "white",
                      scale = 2.5, rel_min_height = .01) +
  labs(x = "Temperature (¬∞F)", y = "Year") +
  guides(fill = FALSE) +
  theme_ridges()
```

You can also get rid of the overlap using values below 1 for the scaling argument (but this somehow contradicts the idea of ridge plots...). Here is an example additionally using the viridis color gradient and the in-build theme:

```{r ridges-viridis}
ggplot(chic, aes(x = temp, y = season, fill = ..x..)) +
  geom_density_ridges_gradient(scale = .9, gradient_lwd = .5,
                               color = "black") +
  scale_fill_viridis_c(option = "plasma", name = "") +
  labs(x = "Temperature (¬∞F)", y = "Season") +
  theme_ridges(font_family = "Roboto Condensed", grid = FALSE)
```

We can also compare several groups per ridgeline and coloring them according to their group. This follows the idea of [Marc Belzunces](https://twitter.com/marcbeldata/status/888697140268204032).

```{r ridges-groups}
library(tidyverse)
## only plot extreme season using dplyr from the tidyverse
ggplot(data = filter(chic, season %in% c("Summer", "Winter")),
         aes(x = temp, y = year, fill = paste(year, season))) +
  geom_density_ridges(alpha = .7, rel_min_height = .01,
                      color = "white", from = -5, to = 95) +
  scale_fill_cyclical(breaks = c("1997 Summer", "1997 Winter"),
                      labels = c(`1997 Summer` = "Summer",
                                 `1997 Winter` = "Winter"),
                      values = c("tomato", "dodgerblue"),
                      name = "Season:", guide = "legend") +
  theme_ridges(grid = FALSE) +
  labs(x = "Temperature (¬∞F)", y = "Year")
```

The `{ggridges}` package is also helpful to create histograms for different groups using `stat = "binline"` in the `geom_density_ridges()` command:

```{r ridges-histo}
ggplot(chic, aes(x = temp, y = factor(year), fill = year)) +
  geom_density_ridges(stat = "binline", bins = 25, scale = .9,
                      draw_baseline = FALSE, show.legend = FALSE) +
  theme_minimal() +
  labs(x = "Temperature (¬∞F)", y = "Season")
```

[‚Üë Jump back to Table of Content.](#toc)<br><br>



## Trabalhando com Ribbons (AUC, CI, etc.) {#ribbons}

This is not a perfect dataset for demonstrating this, but using ribbon can be useful. In this example we will create a 30-day running average using the filter() function so that our ribbon is not too noisy.

```{r ribbon-default}
chic$o3run <- as.numeric(stats::filter(chic$o3, rep(1/30, 30), sides = 2))
ggplot(chic, aes(x = date, y = o3run)) +
   geom_line(color = "chocolate", lwd = .8) +
   labs(x = "Year", y = "Ozone")
```

How does it look if we fill in the area below the curve using the `geom_ribbon()` function?

```{r geom-ribbon-AUC}
ggplot(chic, aes(x = date, y = o3run)) +
   geom_ribbon(aes(ymin = 0, ymax = o3run),
               fill = "orange", alpha = .4) +
   geom_line(color = "chocolate", lwd = .8) +
   labs(x = "Year", y = "Ozone")
```

Nice to indicate the [area under the curve (AUC)](https://en.wikipedia.org/wiki/Area_under_the_curve_(pharmacokinetics)) but this is not the conventional way to use `geom_ribbon()`.

üíÅ *And actually a nicer way to achieve the same is `geom_area()`.*

<details>
  <summary>Expand to see example.</summary>
```{r geom-area-AUC}
ggplot(chic, aes(x = date, y = o3run)) +
   geom_area(color = "chocolate", lwd = .8,
             fill = "orange", alpha = .4) +
   labs(x = "Year", y = "Ozone")
```
</details>

Instead, we draw a ribbon that gives us one standard deviation above and below our data:

```{r geom-ribbon-range}
chic$mino3 <- chic$o3run - sd(chic$o3run, na.rm = TRUE)
chic$maxo3 <- chic$o3run + sd(chic$o3run, na.rm = TRUE)
ggplot(chic, aes(x = date, y = o3run)) +
   geom_ribbon(aes(ymin = mino3, ymax = maxo3), alpha = .5,
               fill = "darkseagreen3", color = "transparent") +
   geom_line(color = "aquamarine4", lwd = .7) +
   labs(x = "Year", y = "Ozone")
```

[‚Üë Jump back to Table of Content.](#toc)<br><br> 



## Trabalhando com Smoothings {#smooths}

It is amazingly easy to add smoothing to your data using `{ggplot2}`.


##### Default: Adding a LOESS or GAM Smoothing

You can simply use `stat_smooth()`‚Äî not even a formula is required. This adds a LOESS (locally weighted scatter plot smoothing, `method = "loess"`) if you have fewer than 1000 points or a GAM (generalized additive model, `method = "gam"`) otherwise. Since we have more than 1000 points, the smoothing is based on a GAM:

```{r stat-smooth, message=TRUE}
ggplot(chic, aes(x = date, y = temp)) +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  stat_smooth() +
  geom_point(color = "gray40", alpha = .5)
```
üí° **In most cases one wants the points to be on top of the ribbon so make sure you always call the smoothing before you add the points.**

##### Adding a Linear Fit

Though the default is a LOESS or GAM smoothing, it is also easy to add a standard linear fit:

```{r LM}
ggplot(chic, aes(x = temp, y = death)) +
   labs(x = "Temperature (¬∞F)", y = "Deaths") +
   stat_smooth(method = "lm", se = FALSE,
               color = "firebrick", size = 1.3) +
   geom_point(color = "gray40", alpha = .5)
```


##### Specifying the Formula for Smoothing

`{ggplot2}` allows you to specify the model you want it to use. Maybe you want to use a [polynomial regression](https://en.wikipedia.org/wiki/Polynomial_regression)?

```{r GAM-spec1}
ggplot(chic, aes(x = o3, y = temp))+
  labs(x = "Ozone Level", y = "Temperature (¬∞F)") +
  geom_smooth(
    method = "lm",
    formula = y ~ x + I(x^2) + I(x^3) + I(x^4) + I(x^5),
    color = "black",
    fill = "firebrick"
  ) +
  geom_point(color = "gray40", alpha = .3)
```

<details>
  <summary>&#128129; <i>Huh, `geom_smooth()`? There is an important difference between `geom` and `stat` layers but here it really doesn't matter which one you use. Expand to compare both.</i></summary>
```{r geom-stat-smooth-a}
ggplot(chic, aes(x = o3, y = temp))+
  labs(x = "Ozone Level", y = "Temperature (¬∞F)") +
  geom_smooth(stat = "smooth") + ## the default
  geom_point(color = "gray40", alpha = .3)
```

```{r geom-stat-smooth-b}
ggplot(chic, aes(x = o3, y = temp))+
  labs(x = "Ozone Level", y = "Temperature (¬∞F)") +
  stat_smooth(geom = "smooth") + ## the default
  geom_point(color = "gray40", alpha = .3)
```
</details>

Or lets say you want to increase the GAM dimension (add some additional wiggles to the smooth):

```{r GAM-spec2, include=TRUE, cache=TRUE}
cols <- c("darkorange2", "firebrick", "dodgerblue3")
ggplot(chic, aes(x = date, y = temp)) +
  geom_point(color = "gray40", alpha = .3) +
  labs(x = "Year", y = "Temperature (¬∞F)") +
  stat_smooth(aes(col = "1000"),
              method = "gam",
              formula = y ~ s(x, k = 1000),
              se = FALSE, size = 1.3) +
  stat_smooth(aes(col = "100"),
              method = "gam",
              formula = y ~ s(x, k = 100),
              se = FALSE, size = 1) +
  stat_smooth(aes(col = "10"),
              method = "gam",
              formula = y ~ s(x, k = 10),
              se = FALSE, size = .8) +
  scale_color_manual(name = "k", values = cols)
```

[‚Üë Jump back to Table of Content.](#toc)<br><br>


## Trabalhando com Interactive Plots {#interactive}

The following collection lists libraries that can be used in combination with `{ggplot2}` or on their own to create interactive visualizations in R (often making use of existing JavaScript libraries).


##### Combination of {ggplot2} and {shiny}

`{shiny}` is a package from [RStudio](https://rstudio.com/) that makes it incredibly easy to build interactive web applications with R. For an introduction and live examples, visit the [Shiny homepage](http://shiny.rstudio.com/).

To look at the potential use, you can check out the Hello Shiny examples. This is the first one:

```{r shiny, eval=FALSE}
library(shiny)
runExample("01_hello")
```

Of course, one can use ggplots in these apps. This example demonstrates the possibility to add some interactive user experience:

```{r shiny-04, eval=FALSE}
runExample("04_mpg")
```


##### Plot.ly via {plotly} and {ggplot2}

[Plot.ly](https://chart-studio.plotly.com/feed/#/) is a tool for creating online, interactive graphics and web apps. The [`{plotly}` package](https://plot.ly/r/getting-started/) enables you to create those directly from your `{ggplot2}` plots and the workflow is surprisingly easy and [can be done from within R](https://plotly-r.com/). However, some of your theme settings might be changed and need to be modified manually afterwards. Also, and unfortunately, it is not straightforward to create facets or true multi-panel plots that scale nicely.

```{r plotly, echo=-3}
g <- ggplot(chic, aes(date, temp)) +
  geom_line(color = "grey") +
  geom_point(aes(color = season)) +
  scale_color_brewer(palette = "Dark2", guide = "none") +
  labs(x = NULL, y = "Temperature (¬∞F)") +
  theme_bw()
g
library(plotly)
ggplotly(g)
```

Here, for example, it keeps the overall theme setting but adds the legend again.


##### ggiraph and ggplot2

[`{ggiraph}`](https://davidgohel.github.io/ggiraph/index.html) is an R package that allows you to create dynamic `{ggplot2}` graphs. This allows you to add tooltips, animations and JavaScript actions to the graphics. The package also allows the selection of graphical elements when used in Shiny applications.

```{r ggiraph}
library(ggiraph)
g <- ggplot(chic, aes(date, temp)) +
  geom_line(color = "grey") +
  geom_point_interactive(
    aes(color = season, tooltip = season, data_id = season)
  ) +
  scale_color_brewer(palette = "Dark2", guide = "none") +
  labs(x = NULL, y = "Temperature (¬∞F)") +
  theme_bw()
girafe(ggobj = g)
```

##### Highcharts via {highcharter}

[Highcharts](https://www.highcharts.com/), a software library for interactive charting, is another visualization library written in pure JavaScript that has been ported to R. The package [`{highcharter}`](https://jkunst.com/highcharter/) makes it possible to use them‚Äîbut be aware that Highcharts is only free in case of non-commercial use.

```{r highcharter}
library(highcharter)
hchart(chic, "scatter", hcaes(x = date, y = temp, group = season))
```


##### Echarts via {echarts4r}

[Apache ECharts](https://echarts.apache.org/en/index.html) is a free, powerful charting and visualization library offering an easy way of building intuitive, interactive, and highly customizable charts. Even though it is written in pure JavaScript, one can use it in R via the [`{echarts4r}` library](https://echarts4r.john-coene.com/) thanks to [John Coene](https://john-coene.com/). Check out the impressive [example gallery](https://echarts4r.john-coene.com/articles/chart_types.html) or these two apps ([App 1](https://johncoene.shinyapps.io/fopi-contest/) and [App 2](https://berlinbikes.correlaid.org/)) making use of the `{echarts4r}` functionality.

```{r echarts4r}
library(echarts4r)
chic %>%
  e_charts(date) %>%
  e_scatter(temp, symbol_size = 7) %>%
  e_visual_map(temp) %>%
  e_y_axis(name = "Temperature (¬∞F)") %>%
  e_legend(FALSE)
```


##### Chart.js via {charter}

[charter](https://github.com/JohnCoene/charter) is another package developed by John Coene that enables the use of a JavaScript visualization library in R. The package allows you to build interactive plots with the help of the [Charts.js framework](https://www.chartjs.org/).

```{r charter, eval=FALSE}
library(charter)
chic$date_num <- as.numeric(chic$date)
## doesn't work with class date
chart(data = chic, caes(date_num, temp)) %>%
  c_scatter(caes(color = season, group = season)) %>%
  c_colors(RColorBrewer::brewer.pal(4, name = "Dark2"))
```
(The example doesn't work in Rmarkdown.)


[‚Üë Jump back to Table of Content.](#toc)<br><br>


## Remarks, Tipps & Resources {#tipps}

##### Using `ggplot()` in Loops and Functions

The grid-based graphics functions in lattice and ggplot2 create a graph object. When you use these functions interactively at the command line, the result is automatically printed, but in `source()` or inside your own functions you will need an explicit `print()` statement, i.e. `print(g)` in most of our examples. See also the [Q&A page of R](https://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-do-lattice_002ftrellis-graphics-not-work_003f).


##### Additional Resources

* ["ggplot2: Elegant Graphics for Data Analysis"](https://ggplot2-book.org/) by Hadley Wickham, available via open-access!
* ["Fundamentals of Data Visualization"](http://serialmentor.com/dataviz/) by Claus O. Wilke about data visualization in general but using `{ggplot2}`. (You can find the codes on [his GitHub profile](https://github.com/clauswilke/dataviz).)
* ["Cookbook for R"](http://www.cookbook-r.com/Graphs/)
by Winston Chang with recipes to produce R plots
* Gallery of the [Top 50 ggplot2 visualizations](http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html)
* Gallery of [`{ggplot2}` extension packages](https://exts.ggplot2.tidyverse.org/gallery/)
* [How to extend `{ggplot2}`](https://cran.r-project.org/web/packages/ggplot2/vignettes/extending-ggplot2.html) by Hadley Wickham
* The fantastic [R4DS Online Learning Community](https://www.rfordatasci.com/) that offers help and mentoring for all things related to the content of the ["R for Data Science" book](r4ds.had.co.nz/) by Hadley Wickham
* [#TidyTuesday](https://github.com/rfordatascience/tidytuesday), a weekly social data project focusing on ggplots‚Äîcheck also [#TidyTuesday on Twitter](https://twitter.com/hashtag/TidyTuesday?lang=en) and [this collection of contributions by Neil Grantham](https://nsgrantham.com/tidytuesdayrocks/)
* A two-part, 4.5-hours tutorial series by Thomas Linn Pedersen ([Part 1](https://www.youtube.com/watch?v=h29g21z0a68) | [Part 2](https://www.youtube.com/watch?v=0m4yywqNPVY))

[‚Üë Jump back to Table of Content.](#toc)<br><br>


***

<details>
<summary style='font-size:10pt;'>R Session Info</summary>

```{r session-info, echo=FALSE, purl=FALSE}
sessionInfo()
```